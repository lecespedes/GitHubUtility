<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="device-width, initial-scale=1.0">
  <title>2D and 3D Color Visualization</title>
  <style>
    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #f5f5f5;
      margin: 0;
      padding: 20px;
    }
    .canvas-container {
      display: flex;
      flex-direction: row;
      gap: 10px;
      justify-content: center;
      flex-wrap: wrap;
      margin: 10px 0;
    }
    canvas {
      border: 1px solid #aaa;
      border-radius: 8px;
      background: #fff;
    }
    #tooltip {
      position: absolute;
      background: #fff;
      border: 1px solid #333;
      border-radius: 4px;
      padding: 5px 10px;
      font-size: 0.9rem;
      pointer-events: none;
      display: none;
      z-index: 2;
      white-space: pre-line;
    }
    .controls {
      margin: 10px 0;
      display: flex;
      gap: 20px;
      align-items: center;
      flex-wrap: wrap;
    }
    button {
      padding: 0.5rem 1rem;
      border: 1px solid #aaa;
      border-radius: 4px;
      background: #eee;
      cursor: pointer;
      font-size: 0.9rem;
    }
    #status {
      margin: 10px 0;
      font-size: 1rem;
      color: #333;
    }
    #hue-select, #saturation-input, #lightness-input, #r-density, #theta-density {
      padding: 0.5rem;
      border: 1px solid #aaa;
      border-radius: 4px;
      font-size: 0.9rem;
    }
    label {
      font-size: 0.9rem;
      color: #333;
    }
    h2 {
      font-size: 1.2rem;
      color: #333;
      margin: 10px 0 5px;
      text-align: center;
    }
    #hue-slider, #lightness-slider {
      width: 200px;
      margin: 0 10px;
    }
    .noUi-target {
      border: none;
      background: #ddd;
      height: 8px;
      border-radius: 4px;
    }
    .noUi-connect {
      background: #4a90e2;
    }
    .noUi-handle {
      border: 1px solid #aaa;
      border-radius: 50%;
      background: #fff;
      width: 16px;
      height: 16px;
      top: -4px;
      cursor: pointer;
    }
    #hue-range-label, #lightness-range-label {
      font-size: 0.9rem;
      color: #333;
    }
    .slider-container, .relationship-toggle, .saturation-button {
      display: flex;
      justify-content: center;
      gap: 10px;
      padding: 10px;
    }
    .mode-toggle {
      display: flex;
      gap: 10px;
      align-items: center;
    }
    .table-container {
      margin: 20px 0;
      width: 80%;
      max-width: 800px;
    }
    .table-container h3 {
      font-size: 1.1rem;
      color: #333;
      margin: 10px 0 5px;
    }
    #mono-hue-table, #mono-sine-table, #rel-primary-table, #rel-related-table {
      border-collapse: collapse;
      width: 100%;
      margin-bottom: 20px;
    }
    #mono-hue-table th, #mono-hue-table td,
    #mono-sine-table th, #mono-sine-table td,
    #rel-primary-table th, #rel-primary-table td,
    #rel-related-table th, #rel-related-table td {
      border: 1px solid #aaa;
      padding: 8px;
      text-align: center;
      font-size: 0.9rem;
    }
    #mono-hue-table th, #mono-sine-table th,
    #rel-primary-table th, #rel-related-table th {
      background: #eee;
      color: #333;
    }
    .color-swatch {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 1px solid #333;
      vertical-align: middle;
      cursor: pointer;
      margin-top: 4px;
    }
    .table-chart-container {
      display: flex;
      flex-direction: row;
      gap: 20px;
      align-items: flex-start;
      width: 100%;
      margin-bottom: 20px;
    }
    .table-chart-container table {
      flex: 1;
    }
    #saturation-chart, #sine-saturation-chart {
      width: 200px;
      height: 200px;
      border: 1px solid #aaa;
      border-radius: 8px;
      background: #fff;
    }
  </style>
  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@v0.176.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@v0.176.0/examples/jsm/"
      }
    }
  </script>
  <script src="https://cdn.jsdelivr.net/npm/nouislider@15.7.1/dist/nouislider.min.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nouislider@15.7.1/dist/nouislider.min.css">
</head>
<body>
  <h1>2D and 3D Color Visualization</h1>
  <div class="controls">
    <button id="load-sample">Load Sample Colors</button>
    <select id="hue-select">
      <option value="">Select Hue</option>
    </select>
    <label for="saturation-input">Saturation (%):</label>
    <input type="number" id="saturation-input" value="100" step="1" min="0" max="100" title="Saturation percentage (0-100)">
    <label for="lightness-input">Lightness (%):</label>
    <input type="number" id="lightness-input" value="50" step="1" min="0" max="100" title="Lightness percentage (0-100)">
    <label for="r-density">L Density:</label>
    <input type="number" id="r-density" value="0.5" step="0.1" min="0.1" max="1" title="Factor to scale lightness points (0.1-1)">
    <label for="theta-density">S Density:</label>
    <input type="number" id="theta-density" value="1" step="0.1" min="0.1" max="1" title="Factor to scale saturation points (0.1-1)">
    <div class="mode-toggle">
      <label><input type="radio" name="mode" value="dome" checked> Dome</label>
      <label><input type="radio" name="mode" value="donut"> Donut</label>
      <label><input type="radio" name="mode" value="sphere"> Sphere</label>
    </div>
  </div>
  <div class="canvas-container">
    <div>
      <h2 id="slCanvasTitle">${UNICODE.theta} = S * 90° vs. L (Lightness)</h2>
      <canvas id="slCanvas" width="500" height="400"></canvas>
      <div class="relationship-toggle">
        <label title="Complementary"><input type="radio" name="relationship" value="complementary">◧</label>
        <label title="2nd Split-Complementary"><input type="radio" name="relationship" value="splitComplementary-2">Ⓨ²</label>
        <label title="2nd Triad"><input type="radio" name="relationship" value="triad-2">▲²</label>
        <label title="2nd Tetrad"><input type="radio" name="relationship" value="tetrad-2">■²</label>
        <label title="2nd Adjacent"><input type="radio" name="relationship" value="adjacent-2">∠²</label>
        <label title="Primary"><input type="radio" name="relationship" value="primary" checked>★</label>
        <label title="1st Adjacent"><input type="radio" name="relationship" value="adjacent-1">∠¹</label>
        <label title="1st Tetrad"><input type="radio" name="relationship" value="tetrad-1">■¹</label>
        <label title="1st Triad"><input type="radio" name="relationship" value="triad-1">▲¹</label>
        <label title="1st Split-Complementary"><input type="radio" name="relationship" value="splitComplementary-1">Ⓨ¹</label>
      </div>
      <div class="saturation-button">
        <button id="show-saturation">Show Saturation Relationships</button>
      </div>
    </div>
    <div>
      <h2>HSL 3D Model (H as ${UNICODE.theta}, S as ${UNICODE.phi}, L as r)</h2>
      <canvas id="threeCanvas" width="500" height="400"></canvas>
      <div class="slider-container">
        <label for="hue-slider">Hue Range:</label>
        <div id="hue-slider"></div>
        <span id="hue-range-label">0°–359°</span>
      </div>
      <div class="slider-container">
        <label for="lightness-slider">Lightness Range:</label>
        <div id="lightness-slider"></div>
        <span id="lightness-range-label">0%–100%</span>
      </div>
    </div>
    <div>
      <h2>Surface Model (S as ${UNICODE.theta}, L as ${UNICODE.phi})</h2>
      <canvas id="newCanvas" width="500" height="400"></canvas>
    </div>
  </div>
  <div id="status">Click "Load Sample Colors" to populate the plots</div>
  <div class="table-container">
    <div class="table-chart-container">
      <div>
        <h3>Monochromatic Hue Relationships (Linear Saturation)</h3>
        <table id="mono-hue-table">
          <thead>
            <tr>
              <th>Relationship</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
      <div>
        <h3>Linear Saturation Relationship Chart</h3>
        <canvas id="saturation-chart" width="200" height="200"></canvas>
      </div>
    </div>
    <div class="table-chart-container">
      <div>
        <h3>Monochromatic Hue Relationships (Sine Wave Saturation)</h3>
        <table id="mono-sine-table">
          <thead>
            <tr>
              <th>Relationship</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
      <div>
        <h3>Sine Wave Saturation Relationship Chart</h3>
        <canvas id="sine-saturation-chart" width="200" height="200"></canvas>
      </div>
    </div>
    <h3>Relational Saturation (Primary Perspective)</h3>
    <table id="rel-primary-table">
      <thead>
        <tr>
          <th>Relationship</th>
          <th>Saturation (%)</th>
          <th>Color</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
    <h3>Relational Saturation (Related Perspective)</h3>
    <table id="rel-related-table">
      <thead>
        <tr>
          <th>Relationship</th>
          <th>Saturation (%)</th>
          <th>Color</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>
  <div id="tooltip"></div>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // Global variables
    let currentMode = 'dome';
    let currentRelationship = 'primary';
    let rDensity = 0.5;
    let thetaDensity = 1.0;
    let showSaturationRelationships = false;
    let colors = [];
    let minHue = 0;
    let maxHue = 359;
    let minLightness = 0;
    let maxLightness = 100;
    let selectedHue = 0;
    let selectedSaturation = 100;
    let selectedLightness = 50;
    let slCanvas = null;
    let slCtx = null;
    let centerX = 0;
    let centerY = 0;
    let maxRadius = 180;

    // Three.js setup for threeCanvas
    const threeCanvas = document.getElementById('threeCanvas');
    const scene = new THREE.Scene();
    const DOME_RADIUS = 300;
    const BASE_SPHERE_SIZE = 3;
    const BASE_POINT_RADIUS = 2.5;
    const camera = new THREE.PerspectiveCamera(45, threeCanvas.width / threeCanvas.height, 0.1, DOME_RADIUS*5);
    const renderer = new THREE.WebGLRenderer({ canvas: threeCanvas, alpha: true });
    renderer.setSize(threeCanvas.width, threeCanvas.height);
    camera.aspect = threeCanvas.width / threeCanvas.height;
    camera.updateProjectionMatrix();
    camera.position.set(DOME_RADIUS, DOME_RADIUS*3, DOME_RADIUS*1.5);
    camera.lookAt(0, DOME_RADIUS/2, 0);

    const controls = new OrbitControls(camera, threeCanvas);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.screenSpacePanning = true;
    controls.minDistance = 50;
    controls.maxDistance = 1000;
    controls.target.set(0, DOME_RADIUS / 2, 0);
    controls.update();

    // Three.js setup for newCanvas
    const newCanvas = document.getElementById('newCanvas');
    const newScene = new THREE.Scene();
    const FIXED_RADIUS = 200;
    const newCamera = new THREE.PerspectiveCamera(45, newCanvas.width / newCanvas.height, 0.1, FIXED_RADIUS*5);
    const newRenderer = new THREE.WebGLRenderer({ canvas: newCanvas, alpha: true });
    newRenderer.setSize(newCanvas.width, newCanvas.height);
    newCamera.aspect = newCanvas.width / newCanvas.height;
    newCamera.updateProjectionMatrix();
    newCamera.position.set(FIXED_RADIUS, FIXED_RADIUS*3, FIXED_RADIUS*1.5);
    newCamera.lookAt(0, FIXED_RADIUS/2, 0);

    const newControls = new OrbitControls(newCamera, newCanvas);
    newControls.enableDamping = true;
    newControls.dampingFactor = 0.05;
    newControls.screenSpacePanning = true;
    newControls.minDistance = 50;
    newControls.maxDistance = 1000;
    newControls.target.set(0, FIXED_RADIUS / 2, 0);
    newControls.update();

    let instancedMesh = null;
    let newInstancedMesh = null;
    let dashedEdges = null;
    let newDashedEdges = null;
    let hueLabelsGroup = null;
    let newHueLabelsGroup = null;
    let sAxis = null;
    let lAxis = null;
    let sLabel = null;
    let lLabel = null;
    let newSAxis = null;
    let newLAxis = null;
    let newSLabel = null;
    let newLLabel = null;

    const UNICODE = {
      star: "\u2605",
      reflect: "\u25E7",
      circled_y: "\u24CE",
      triangle: "\u25B2",
      filled_square: "\u25A0",
      angle: "\u2220",
      theta: "\u03B8",
      phi: "\u03C6"
    };

    const relationshipOrder = [
      { key: 'complementary', index: 0, offset: 180, name: 'Complementary', symbol: UNICODE.reflect, group: 'complementary' },
      { key: 'splitComplementary-2', index: 1, offset: 210, name: '2nd Split-Complementary', symbol: UNICODE.circled_y, group: 'splitComplementary' },
      { key: 'triad-2', index: 1, offset: 240, name: '2nd Triad', symbol: UNICODE.triangle, group: 'triad' },
      { key: 'tetrad-2', index: 1, offset: 270, name: '2nd Tetrad', symbol: UNICODE.filled_square, group: 'tetrad' },
      { key: 'adjacent-2', index: 1, offset: 330, name: '2nd Adjacent', symbol: UNICODE.angle, group: 'adjacent' },
      { key: 'primary', index: 0, offset: 0, name: 'Primary', symbol: UNICODE.star, group: 'primary' },
      { key: 'adjacent-1', index: 0, offset: 30, name: '1st Adjacent', symbol: UNICODE.angle, group: 'adjacent' },
      { key: 'tetrad-1', index: 0, offset: 90, name: '1st Tetrad', symbol: UNICODE.filled_square, group: 'tetrad' },
      { key: 'triad-1', index: 0, offset: 120, name: '1st Triad', symbol: UNICODE.triangle, group: 'triad' },
      { key: 'splitComplementary-1', index: 0, offset: 150, name: '1st Split-Complementary', symbol: UNICODE.circled_y, group: 'splitComplementary' }
    ];

    const saturationRelationships = [  
      { name: '1st Tetrad', offset: 90, symbol: UNICODE.filled_square + '¹' },
      { name: '1st Triad', offset: 120, symbol: UNICODE.triangle + '¹' },
      { name: '1st Split-Complementary', offset: 150, symbol: UNICODE.circled_y + '¹' },
      { name: 'Complementary', offset: 180, symbol: UNICODE.reflect },
      { name: '2nd Split-Complementary', offset: 210, symbol: UNICODE.circled_y + '²' },
      { name: '2nd Triad', offset: 240, symbol: UNICODE.triangle + '²' },
      { name: '2nd Tetrad', offset: 270, symbol: UNICODE.filled_square + '²' },
      { name: 'Primary', offset: 360, symbol: UNICODE.star },
    ];

    function toDegrees(radians) {
      return parseFloat((radians * (180 / Math.PI)) % 360);
    }

    function toRadians(degrees) {
      return parseFloat((degrees % 360) * (Math.PI / 180));
    }

    function normRadians(radians) {
      return parseFloat(((radians % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI));
    }

    // Parameter _range should be expressed in pi
    //Parameter _value should be from 0 to 1 
    function getAngularValue(_value , _range){
      const value = parseFloat(_value);
      if (value === 1) return parseFloat(2 * Math.PI); // Handle 100% saturation
      if (value === 0) return 0; // Handle 0% saturation
      const sinValue = parseFloat(2 * value - 1);
      if (Math.abs(sinValue) > 1) return 0;
      const angle = parseFloat((_range/Math.PI) * Math.asin(sinValue) + Math.PI/2);
      return angle;
    }

    function getStartingAngle(saturation) { //2PI range
      const s = parseFloat(saturation / 100);
      if (s === 1) return parseFloat(2 * Math.PI); // Handle 100% saturation
      if (s === 0) return 0; // Handle 0% saturation
      const sinValue = parseFloat(2 * s - 1);
      if (Math.abs(sinValue) > 1) return 0;
      const angle = parseFloat(2 * Math.asin(sinValue) + Math.PI);
      return angle;
    }

    function getStartingAngleSinTable(saturation) { //PI range
      const s = parseFloat(saturation / 100);
      if (s === 1) return parseFloat(Math.PI); // Handle 100% saturation
      if (s === 0) return 0; // Handle 0% saturation
      const sinValue = parseFloat(2 * s - 1);
      if (Math.abs(sinValue) > 1) return 0;
      const angle = parseFloat(Math.asin(sinValue) + Math.PI / 2);
      return angle;
    }

    function createLabel(text, position, color, fontFamily = 'Helvetica, Arial, sans-serif', fontWeight = 400, fontSize = 96) {
      const canvas = document.createElement('canvas');
      canvas.width = 256;
      canvas.height = 256;
      const context = canvas.getContext('2d');
      context.fillStyle = color;
      context.font = `${fontWeight} ${fontSize}px ${fontFamily}`;
      context.textAlign = 'left';
      context.textBaseline = 'middle';
      context.fillText(text, 10, 128);
      const texture = new THREE.CanvasTexture(canvas);
      const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
      const sprite = new THREE.Sprite(spriteMaterial);
      sprite.position.copy(position);
      sprite.scale.set(40, 40, 1);
      return sprite;
    }

    function createAxis(_type, _label, _axisLength, _color) {
      const axisGeometry = new THREE.BufferGeometry();
      const axisMaterial = new THREE.LineBasicMaterial({ color: _color });
      let axisLabel = null;
      switch (_type) {
        case "x":
          axisGeometry.setFromPoints([new THREE.Vector3(parseFloat(-_axisLength + 10), 0, 0), new THREE.Vector3(parseFloat(_axisLength + 10), 0, 0)]);
          axisLabel = createLabel(_label, new THREE.Vector3(parseFloat(_axisLength + 30), 0, 0), _color);
          break;
        case "y":
          axisGeometry.setFromPoints([new THREE.Vector3(0, parseFloat(-_axisLength), 0), new THREE.Vector3(0, parseFloat(_axisLength + 10), 0)]);
          axisLabel = createLabel(_label, new THREE.Vector3(0, parseFloat(_axisLength + 30), 0), _color);
          break;
        case "z":
          axisGeometry.setFromPoints([new THREE.Vector3(0, 0, parseFloat(-_axisLength + 10)), new THREE.Vector3(0, 0, parseFloat(_axisLength + 10))]);
          axisLabel = createLabel(_label, new THREE.Vector3(0, 0, parseFloat(_axisLength + 30)), _color);
          break;
      }
      const axis = new THREE.Line(axisGeometry, axisMaterial);
      newScene.add(axis);
      newScene.add(axisLabel);
    }

    function createSphereMarkers(_type, _radius, _range, _color = "#000000", _direction = 1, _rotation = 0, _counterClockwise = false) {
      const markerDist = parseFloat(_radius + 15);
      const sphereLabels = new THREE.Group();
      let x = 0, y = 0, z = 0;
      for (let degrees = 0; degrees <= parseFloat(_range); degrees += 15) {
        const radians = toRadians(degrees);
        switch (_type) {
          case "x":
            x = parseFloat(markerDist * Math.cos(radians + parseFloat(_rotation)));
            z = _counterClockwise ? parseFloat(-markerDist * Math.sin(radians + parseFloat(_rotation))) : parseFloat(markerDist * Math.sin(radians + parseFloat(_rotation)));
            break;
          case "y":
            x = _counterClockwise ? parseFloat(-markerDist * Math.sin(radians + parseFloat(_rotation))) : parseFloat(markerDist * Math.sin(radians + parseFloat(_rotation)));
            y = parseFloat(markerDist * Math.cos(radians + parseFloat(_rotation)));
            break;
          case "z":
            y = _counterClockwise ? parseFloat(-markerDist * Math.sin(radians + parseFloat(_rotation))) : parseFloat(markerDist * Math.sin(radians + parseFloat(_rotation)));
            z = parseFloat(markerDist * Math.cos(radians + parseFloat(_rotation)));
            break;
        }
        const labelPos = new THREE.Vector3(x, y, z);
        const label = createLabel((_direction * degrees).toString(), labelPos, _color);
        sphereLabels.add(label);
      }
      newScene.add(sphereLabels);
    }

    function debounce(func, wait) {
      let timeout;
      return function (...args) {
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(this, args), wait);
      };
    }

    function hslToHex(h, s, l) {
      h = parseFloat(h / 360);
      s = parseFloat(s / 100);
      l = parseFloat(l / 100);
      let r, g, b;
      if (s === 0) {
        r = g = b = l;
      } else {
        const hue2rgb = (p, q, t) => {
          if (t < 0) t += 1;
          if (t > 1) t -= 1;
          if (t < parseFloat(1/6)) return parseFloat(p + (q - p) * 6 * t);
          if (t < parseFloat(1/2)) return q;
          if (t < parseFloat(2/3)) return parseFloat(p + (q - p) * (parseFloat(2/3) - t) * 6);
          return p;
        };
        const q = l < parseFloat(0.5) ? parseFloat(l * (1 + s)) : parseFloat(l + s - l * s);
        const p = parseFloat(2 * l - q);
        r = hue2rgb(p, q, parseFloat(h + 1/3));
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, parseFloat(h - 1/3));
      }
      const toHex = x => {
        const hex = Math.round(parseFloat(x * 255)).toString(16);
        return hex.length === 1 ? '0' + hex : hex;
      };
      return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
    }

    function updateMonoHueTable(selectedHue, selectedSaturation, selectedLightness) {
      const table = document.querySelector('#mono-hue-table');
      const thead = table.querySelector('thead tr');
      const tbody = table.querySelector('tbody');
      thead.innerHTML = '<th>Relationship</th>';
      tbody.innerHTML = '';

      const hues = relationshipOrder.map(rel => ({
        hue: parseFloat(((selectedHue + rel.offset) % 360 + 360) % 360),
        symbol: rel.symbol + (rel.index === 0 ? '¹' : rel.index === 1 ? '²' : ''),
        offset: rel.offset
      }));

      hues.sort((a, b) => {
        let angleA = parseFloat(a.offset % 360);
        let angleB = parseFloat(b.offset % 360);
        if (angleA < 180) angleA += 360;
        if (angleB < 180) angleB += 360;
        return angleA - angleB;
      });

      hues.forEach(hueObj => {
        const th = document.createElement('th');
        th.textContent = hueObj.symbol;
        thead.appendChild(th);
      });

      const theta0 = getStartingAngle(selectedSaturation);

      saturationRelationships.forEach(rel => {
        const row = document.createElement('tr');
        row.innerHTML = `<td>${rel.symbol} ${rel.name} (${rel.offset}°)</td>`;
        hues.forEach(hueObj => {
          let s, thetaRel;
          if (rel.offset === 360) {
            s = parseFloat(selectedSaturation); // Primary uses input saturation
            thetaRel = parseFloat(theta0 + toRadians(360));
          } else {
            thetaRel = parseFloat(theta0 + toRadians(rel.offset));
            const thetaRelNormalized = normRadians(thetaRel);
            s = Math.round(parseFloat(((Math.sin((thetaRelNormalized - parseFloat(Math.PI))/2) + 1) / 2) * 100));
          }
          const hex = hslToHex(hueObj.hue, s, selectedLightness);
          const td = document.createElement('td');
          td.innerHTML = `
            <div>${s}%</div>
            <div class="color-swatch" style="background-color: ${hex};" title="HSL(${hueObj.hue.toFixed(0)}°, ${s}%, ${selectedLightness}%)"></div>
          `;
          row.appendChild(td);
        });
        tbody.appendChild(row);
      });
    }

    function updateMonoSineTable(selectedHue, selectedSaturation, selectedLightness) {
      const table = document.querySelector('#mono-sine-table');
      const thead = table.querySelector('thead tr');
      const tbody = table.querySelector('tbody');
      thead.innerHTML = '<th>Relationship</th>';
      tbody.innerHTML = '';

      const hues = relationshipOrder.map(rel => ({
        hue: parseFloat(((selectedHue + rel.offset) % 360 + 360) % 360),
        symbol: rel.symbol + (rel.index === 0 ? '¹' : rel.index === 1 ? '²' : ''),
        offset: rel.offset
      }));

      hues.sort((a, b) => {
        let angleA = parseFloat(a.offset % 360);
        let angleB = parseFloat(b.offset % 360);
        if (angleA < 180) angleA += 360;
        if (angleB < 180) angleB += 360;
        return angleA - angleB;
      });

      hues.forEach(hueObj => {
        const th = document.createElement('th');
        th.textContent = hueObj.symbol;
        thead.appendChild(th);
      });

      const theta0 = getStartingAngleSinTable(selectedSaturation);

      saturationRelationships.forEach(rel => {
        const row = document.createElement('tr');
        row.innerHTML = `<td>${rel.symbol} ${rel.name} (${rel.offset}°)</td>`;
        hues.forEach(hueObj => {
          let s, thetaRel;
          if (rel.offset === 360) {
            s = parseFloat(selectedSaturation); // Primary uses input saturation
            thetaRel = parseFloat(theta0 + toRadians(360));
          } else {
            thetaRel = parseFloat(theta0 + toRadians(rel.offset));
            const thetaRelNormalized = normRadians(thetaRel);
            s = Math.round(parseFloat(((Math.sin(thetaRelNormalized - parseFloat(Math.PI)/2) + 1) / 2) * 100));
          }
          const hex = hslToHex(hueObj.hue, s, selectedLightness);
          const td = document.createElement('td');
          td.innerHTML = `
            <div>${s}%</div>
            <div class="color-swatch" style="background-color: ${hex};" title="HSL(${hueObj.hue.toFixed(0)}°, ${s}%, ${selectedLightness}%)"></div>
          `;
          row.appendChild(td);
        });
        tbody.appendChild(row);
      });
    }

    function updateSaturationChart(selectedSaturation) {
      const canvas = document.getElementById('saturation-chart');
      const ctx = canvas.getContext('2d');
      const centerX = parseFloat(canvas.width / 2);
      const centerY = parseFloat(canvas.height / 2);
      const radius = 80;
      const hitRadius = 10;

      ctx.clearRect(0, 0, canvas.width, canvas.height);

      ctx.beginPath();
      ctx.arc(centerX, centerY, radius, 0, parseFloat(2 * Math.PI));
      ctx.strokeStyle = '#aaa';
      ctx.lineWidth = 1;
      ctx.stroke();

      const theta0 = getStartingAngle(selectedSaturation);

      const points = saturationRelationships.map(rel => {
        const offsetRad = toRadians(rel.offset);
        const thetaRel = parseFloat(theta0 + offsetRad);
        const thetaRelNormalized = normRadians(thetaRel);
        const s = rel.offset === 360 ? parseFloat(selectedSaturation) : Math.round(parseFloat(((Math.sin(thetaRelNormalized - parseFloat(Math.PI)/2) + 1) / 2) * 100));
        const theta = parseFloat(thetaRelNormalized - parseFloat(Math.PI / 2)); // Plot at normalized computed angle
        const x = parseFloat(centerX + radius * Math.cos(theta));
        const y = parseFloat(centerY + radius * Math.sin(theta));
        return { x, y, symbol: rel.symbol, offset: rel.offset, saturation: s, thetaRel: thetaRelNormalized };
      });

      ctx.fillStyle = '#333';
      ctx.font = '16px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      points.forEach(point => {
        ctx.fillText(point.symbol, point.x, point.y);
      });

      const tooltip = document.getElementById('tooltip');
      canvas.onmousemove = (event) => {
        const mouseX = parseFloat(event.offsetX);
        const mouseY = parseFloat(event.offsetY);

        let found = false;
        points.forEach(point => {
          const dx = parseFloat(mouseX - point.x);
          const dy = parseFloat(mouseY - point.y);
          if (Math.sqrt(dx * dx + dy * dy) < hitRadius) {
            tooltip.style.display = 'block';
            tooltip.style.left = `${event.pageX + 10}px`;
            tooltip.style.top = `${event.pageY + 10}px`;
            const angleDeg = toDegrees(point.thetaRel);
            tooltip.textContent = `${point.symbol} ${UNICODE.theta}: ${angleDeg.toFixed(0)}°\nS: ${point.saturation}%`;
            found = true;
          }
        });

        if (!found) {
          tooltip.style.display = 'none';
        }
      };

      canvas.onmouseout = () => {
        tooltip.style.display = 'none';
      };
    }

    function updateSineSaturationChart(selectedSaturation) {
      const canvas = document.getElementById('sine-saturation-chart');
      const ctx = canvas.getContext('2d');
      const centerX = parseFloat(canvas.width / 2);
      const centerY = parseFloat(canvas.height / 2);
      const radius = 80;
      const hitRadius = 10;

      ctx.clearRect(0, 0, canvas.width, canvas.height);

      ctx.beginPath();
      ctx.arc(centerX, centerY, radius, 0, parseFloat(2 * Math.PI));
      ctx.strokeStyle = '#aaa';
      ctx.lineWidth = 1;
      ctx.stroke();

      const theta0 = getStartingAngleSinTable(selectedSaturation);

      const points = saturationRelationships.map(rel => {
        const offsetRad = toRadians(rel.offset);
        const thetaRel = parseFloat(theta0 + offsetRad);
        const thetaRelNormalized = normRadians(thetaRel);
        const s = rel.offset === 360 ? parseFloat(selectedSaturation) : Math.round(parseFloat(((Math.sin(thetaRelNormalized - parseFloat(Math.PI)/2) + 1) / 2) * 100));
        const theta = parseFloat(thetaRelNormalized - parseFloat(Math.PI / 2)); // Plot at normalized computed angle
        const x = parseFloat(centerX + radius * Math.cos(theta));
        const y = parseFloat(centerY + radius * Math.sin(theta));
        return { x, y, symbol: rel.symbol, offset: rel.offset, saturation: s, thetaRel: thetaRelNormalized };
      });

      ctx.fillStyle = '#333';
      ctx.font = '16px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      points.forEach(point => {
        ctx.fillText(point.symbol, point.x, point.y);
      });

      const tooltip = document.getElementById('tooltip');
      canvas.onmousemove = (event) => {
        const mouseX = parseFloat(event.offsetX);
        const mouseY = parseFloat(event.offsetY);

        let found = false;
        points.forEach(point => {
          const dx = parseFloat(mouseX - point.x);
          const dy = parseFloat(mouseY - point.y);
          if (Math.sqrt(dx * dx + dy * dy) < hitRadius) {
            tooltip.style.display = 'block';
            tooltip.style.left = `${event.pageX + 10}px`;
            tooltip.style.top = `${event.pageY + 10}px`;
            const angleDeg = toDegrees(point.thetaRel);
            tooltip.textContent = `${point.symbol} ${UNICODE.theta}: ${angleDeg.toFixed(0)}°\nS: ${point.saturation}%`;
            found = true;
          }
        });

        if (!found) {
          tooltip.style.display = 'none';
        }
      };

      canvas.onmouseout = () => {
        tooltip.style.display = 'none';
      };
    }

    function updateRelPrimaryTable(primaryHue, relatedHue, isPrimary) {
      const tableBody = document.querySelector('#rel-primary-table tbody');
      tableBody.innerHTML = '';
      if (isPrimary) return;
      const l = parseFloat(document.getElementById('lightness-input').value);
      const selectedSaturation = parseFloat(document.getElementById('saturation-input').value);
      saturationRelationships.forEach(rel => {
        let angle = rel.offset;
        let s, h;
        if (angle <= 180 || angle === 360) {
          h = parseFloat(primaryHue);
          s = angle === 360 ? selectedSaturation : angle === 180 ? Math.round(parseFloat(100 - selectedSaturation)) : Math.round(parseFloat((angle / 180) * 100));
        } else {
          h = parseFloat(relatedHue);
          s = Math.round(parseFloat(((360 - angle) / 180) * 100));
        }
        const hex = hslToHex(h, s, l);
        const row = document.createElement('tr');
        row.innerHTML = `
          <td>${rel.symbol} ${rel.name} (H=${h.toFixed(0)}°)</td>
          <td>${s}% (${angle}°)</td>
          <td><span class="color-swatch" style="background-color: ${hex};" title="HSL(${h.toFixed(0)}°, ${s}%, ${l}%)"></span></td>
        `;
        tableBody.appendChild(row);
      });
    }

    function updateRelRelatedTable(primaryHue, relatedHue, isPrimary) {
      const tableBody = document.querySelector('#rel-related-table tbody');
      tableBody.innerHTML = '';
      if (isPrimary) return;
      const l = parseFloat(document.getElementById('lightness-input').value);
      const selectedSaturation = parseFloat(document.getElementById('saturation-input').value);
      saturationRelationships.forEach(rel => {
        let angle = rel.offset;
        let s, h;
        if (angle <= 180 || angle === 360) {
          h = parseFloat(relatedHue);
          s = angle === 360 ? selectedSaturation : angle === 180 ? Math.round(parseFloat(100 - selectedSaturation)) : Math.round(parseFloat((angle / 180) * 100));
        } else {
          h = parseFloat(primaryHue);
          s = Math.round(parseFloat(((360 - angle) / 180) * 100));
        }
        const hex = hslToHex(h, s, l);
        const row = document.createElement('tr');
        row.innerHTML = `
          <td>${rel.symbol} ${rel.name} (H=${h.toFixed(0)}°)</td>
          <td>${s}% (${angle}°)</td>
          <td><span class="color-swatch" style="background-color: ${hex};" title="HSL(${h.toFixed(0)}°, ${s}%, ${l}%)"></span></td>
        `;
        tableBody.appendChild(row);
      });
    }

    function setupThreeScene(colors, minHue, maxHue, minLightness, maxLightness) {
      if (instancedMesh) {
        scene.remove(instancedMesh);
        instancedMesh.geometry.dispose();
        instancedMesh.material.dispose();
      }
      if (dashedEdges) {
        scene.remove(dashedEdges);
        dashedEdges.geometry.dispose();
        dashedEdges.material.dispose();
      }
      if (hueLabelsGroup) {
        hueLabelsGroup.children.forEach(child => {
          if (child.material) child.material.dispose();
        });
        scene.remove(hueLabelsGroup);
      }
      if (sAxis) {
        scene.remove(sAxis);
        sAxis.geometry.dispose();
        sAxis.material.dispose();
      }
      if (lAxis) {
        scene.remove(lAxis);
        lAxis.geometry.dispose();
        lAxis.material.dispose();
      }
      if (sLabel) {
        scene.remove(sLabel);
        sLabel.material.dispose();
      }
      if (lLabel) {
        scene.remove(lLabel);
        lLabel.material.dispose();
      }

      let geometry;
      if (currentMode === 'dome') {
        geometry = new THREE.SphereGeometry(DOME_RADIUS, 24, 16, 0, parseFloat(2 * Math.PI), 0, parseFloat(Math.PI / 2));
      } else if (currentMode === 'donut') {
        geometry = new THREE.SphereGeometry(DOME_RADIUS, 24, 16, 0, parseFloat(2 * Math.PI), parseFloat(Math.PI / 4), parseFloat(Math.PI / 2));
      } else if (currentMode === 'sphere') {
        geometry = new THREE.SphereGeometry(DOME_RADIUS, 24, 16);
      }
      const edgesGeometry = new THREE.EdgesGeometry(geometry);
      const dashedMaterial = new THREE.LineDashedMaterial({
        color: 0xaaaaaa,
        dashSize: 2,
        gapSize: 1,
        linewidth: 1
      });
      dashedEdges = new THREE.LineSegments(edgesGeometry, dashedMaterial);
      dashedEdges.computeLineDistances();
      scene.add(dashedEdges);

      const axisLength = 320;
      const lAxisGeometry = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(0, 0, 0),
        new THREE.Vector3(0, parseFloat(axisLength), 0)
      ]);
      const lAxisMaterial = new THREE.LineBasicMaterial({ color: 0x0000ff });
      lAxis = new THREE.Line(lAxisGeometry, lAxisMaterial);
      scene.add(lAxis);

      lLabel = createLabel('L', new THREE.Vector3(10, parseFloat(axisLength + 20), 0), '#000000');
      scene.add(lLabel);

      hueLabelsGroup = new THREE.Group();
      hueLabelsGroup.name = 'hueLabels';
      for (let angle = 0; angle < 360; angle += 15) {
        const theta = toRadians(angle);
        const labelPos = new THREE.Vector3(
          parseFloat(310 * Math.cos(theta)),
          0,
          parseFloat(310 * Math.sin(theta))
        );
        const label = createLabel(angle.toString(), labelPos, '#000000');
        hueLabelsGroup.add(label);
      }
      scene.add(hueLabelsGroup);

      const normalizedMinHue = parseFloat(((minHue % 360) + 360) % 360);
      const normalizedMaxHue = parseFloat(((maxHue % 360) + 360) % 360);
      const filteredColors = colors.filter(color => {
        let { h, l, thetaDeg } = color;
        h = parseFloat(((h % 360) + 360) % 360);
        l = parseFloat(l);
        thetaDeg = parseFloat(thetaDeg);
        let include = l >= parseFloat(minLightness) && l <= parseFloat(maxLightness);
        if (normalizedMinHue <= normalizedMaxHue) {
          include = include && h >= normalizedMinHue && h <= normalizedMaxHue;
        } else {
          include = include && (h >= normalizedMinHue || h <= normalizedMaxHue);
        }
        if (currentMode === 'dome') {
          include = include && thetaDeg <= 90;
        } else if (currentMode === 'donut') {
          const phi = parseFloat((thetaDeg / 90) * (Math.PI / 2) + Math.PI / 4);
          include = include && phi >= parseFloat(Math.PI / 4) && phi <= parseFloat(3 * Math.PI / 4);
        }
        return include;
      });

      const sphereSize = currentMode === 'sphere' ? parseFloat(BASE_SPHERE_SIZE * 2) : parseFloat(BASE_SPHERE_SIZE);
      const pointGeometry = new THREE.SphereGeometry(sphereSize, 6, 6);
      pointGeometry.setAttribute('color', new THREE.BufferAttribute(new Float32Array(pointGeometry.attributes.position.count * 3).fill(1), 3));
      const material = new THREE.MeshBasicMaterial({ vertexColors: true });
      instancedMesh = new THREE.InstancedMesh(pointGeometry, material, filteredColors.length);

      const colorsArray = new Float32Array(filteredColors.length * 3);
      const dummy = new THREE.Object3D();

      filteredColors.forEach((color, i) => {
        let { h, s, l, hex, thetaDeg } = color;
        s = parseFloat(isNaN(s) || s < 0 ? 0 : s);
        l = parseFloat(isNaN(l) || l < 0 ? 0 : l);
        let phi;
        if (currentMode === 'dome') {
          phi = toRadians(thetaDeg);
        } else if (currentMode === 'donut') {
          phi = parseFloat((thetaDeg / 90) * (Math.PI / 2) + Math.PI / 4);
        } else if (currentMode === 'sphere') {
          phi = toRadians(parseFloat(thetaDeg * 2));
        }
        const theta = toRadians(h);
        const r = parseFloat(l * (DOME_RADIUS / 100));
        const x = parseFloat(r * Math.sin(phi) * Math.cos(theta));
        const y = parseFloat(r * Math.cos(phi));
        const z = parseFloat(r * Math.sin(phi) * Math.sin(theta));

        dummy.position.set(x, y, z);
        dummy.updateMatrix();
        instancedMesh.setMatrixAt(i, dummy.matrix);

        const rgb = new THREE.Color(hex);
        colorsArray[i * 3] = rgb.r;
        colorsArray[i * 3 + 1] = rgb.g;
        colorsArray[i * 3 + 2] = rgb.b;
      });

      instancedMesh.instanceColor = new THREE.InstancedBufferAttribute(colorsArray, 3);
      instancedMesh.instanceMatrix.needsUpdate = true;
      instancedMesh.instanceColor.needsUpdate = true;
      scene.add(instancedMesh);

      function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
      }
      animate();
    }

    function setupNewScene(colors, minHue, maxHue, minLightness, maxLightness, selectedHue) {
      if (newInstancedMesh) {
        newScene.remove(newInstancedMesh);
        newInstancedMesh.geometry.dispose();
        newInstancedMesh.material.dispose();
      }
      if (newDashedEdges) {
        newScene.remove(newDashedEdges);
        newDashedEdges.geometry.dispose();
        newDashedEdges.material.dispose();
      }
      if (newHueLabelsGroup) {
        newHueLabelsGroup.children.forEach(child => {
          if (child.material) child.material.dispose();
        });
        newScene.remove(newHueLabelsGroup);
      }
      if (newSAxis) {
        newScene.remove(newSAxis);
        newSAxis.geometry.dispose();
        newSAxis.material.dispose();
      }
      if (newLAxis) {
        newScene.remove(newLAxis);
        newLAxis.geometry.dispose();
        newLAxis.material.dispose();
      }
      if (newSLabel) {
        newScene.remove(newSLabel);
        newSLabel.material.dispose();
      }
      if (newLLabel) {
        newScene.remove(newLLabel);
        newLLabel.material.dispose();
      }

      let geometry;
      if (currentMode === 'dome' || currentMode === 'donut') {
        geometry = new THREE.SphereGeometry(FIXED_RADIUS, 24, 16, parseFloat(-Math.PI / 2), Math.PI, 0, Math.PI);
      } else if (currentMode === 'sphere') {
        geometry = new THREE.SphereGeometry(FIXED_RADIUS, 24, 16, parseFloat(-Math.PI), parseFloat(2 * Math.PI), 0, Math.PI);
      }
      const edgesGeometry = new THREE.EdgesGeometry(geometry);
      const dashedMaterial = new THREE.LineDashedMaterial({
        color: 0xaaaaaa,
        dashSize: 2,
        gapSize: 1,
        linewidth: 1
      });
      newDashedEdges = new THREE.LineSegments(edgesGeometry, dashedMaterial);
      newDashedEdges.computeLineDistances();
      newScene.add(newDashedEdges);

      createAxis("y", "S", FIXED_RADIUS, "#00ff00");
      createAxis("z", "L", FIXED_RADIUS, "#0000ff");
      const thetaRange = currentMode === 'sphere' ? 180 : 90;
      createSphereMarkers("y", FIXED_RADIUS, thetaRange);
      createSphereMarkers("x", FIXED_RADIUS, 180, "#000000", 1, parseFloat(-Math.PI/2), true);

      const points = [];
      const relatedHues = [parseFloat(selectedHue)];
      if (currentRelationship !== 'primary') {
        const rel = relationshipOrder.find(r => r.key === currentRelationship);
        relatedHues.push(parseFloat(((parseFloat(selectedHue) + rel.offset) % 360 + 360) % 360));
      }

      const pointSpacing = currentMode === 'sphere' ? parseFloat(2 * (BASE_SPHERE_SIZE * 2)) : parseFloat(2 * BASE_SPHERE_SIZE);
      const N_l_max = Math.floor(parseFloat(Math.PI / (pointSpacing / FIXED_RADIUS)));
      const N_l = Math.max(1, Math.floor(parseFloat(N_l_max * rDensity)));
      for (let i = 0; i <= N_l; i++) {
        const l = parseFloat((i / N_l) * 100);
        if (l < parseFloat(minLightness) || l > parseFloat(maxLightness)) continue;
        const phi = parseFloat((l / 100) * Math.PI);
        const thetaRange = currentMode === 'sphere' ? Math.PI : parseFloat(Math.PI / 2);
        const arcLength = parseFloat(thetaRange * FIXED_RADIUS * Math.sin(phi));
        const N_points = Math.floor(arcLength / pointSpacing);
        let N_s = Math.max(1, Math.floor(parseFloat(N_points * thetaDensity)));
        if (arcLength === 0) N_s = 1;
        const deltaS = parseFloat(100 / N_s);

        for (let j = 0; j <= N_s; j++) {
          const s = parseFloat(j * deltaS);
          for (const h of relatedHues) {
            const maxTheta = currentMode === 'sphere' ? Math.PI : parseFloat(Math.PI / 2);
            let theta = h === parseFloat(selectedHue) ? parseFloat((s / 100) * maxTheta) : parseFloat(-(s / 100) * maxTheta);
            if (currentMode === 'donut') {
              theta += h === parseFloat(selectedHue) ? parseFloat(Math.PI / 4) : parseFloat(-Math.PI / 4);
            }
            const hex = hslToHex(h, s, l);
            const thetaDeg = h === parseFloat(selectedHue) ? parseFloat((s / 100) * (currentMode === 'sphere' ? 180 : 90)) : parseFloat(-(s / 100) * (currentMode === 'sphere' ? 180 : 90));
            const tableTheta = parseFloat((s === 0 && l === 0) ? 0 : Math.atan2(l, s) * (180 / Math.PI));
            const sqrtSL = parseFloat(Math.sqrt(s * s + l * l));
            points.push({
              code: `H${h}S${s.toFixed(2)}L${l.toFixed(2)}`,
              hex,
              h,
              s,
              l,
              theta: tableTheta,
              sqrtSL,
              thetaDeg,
              phi,
              plotTheta: theta
            });
          }
        }
      }

      const sphereSize = currentMode === 'sphere' ? parseFloat(BASE_SPHERE_SIZE * 2) : parseFloat(BASE_SPHERE_SIZE);
      const pointGeometry = new THREE.SphereGeometry(sphereSize, 6, 6);
      pointGeometry.setAttribute('color', new THREE.BufferAttribute(new Float32Array(pointGeometry.attributes.position.count * 3).fill(1), 3));
      const material = new THREE.MeshBasicMaterial({ vertexColors: true });
      newInstancedMesh = new THREE.InstancedMesh(pointGeometry, material, points.length);

      const colorsArray = new Float32Array(points.length * 3);
      const dummy = new THREE.Object3D();

      points.forEach((color, i) => {
        const { s, l, hex, h, plotTheta, phi } = color;
        const x = parseFloat(FIXED_RADIUS * Math.sin(phi) * Math.sin(plotTheta));
        const y = parseFloat(FIXED_RADIUS * Math.sin(phi) * Math.cos(plotTheta));
        const z = parseFloat(FIXED_RADIUS * Math.cos(phi));

        dummy.position.set(x, y, z);
        dummy.updateMatrix();
        newInstancedMesh.setMatrixAt(i, dummy.matrix);

        const rgb = new THREE.Color(hex);
        colorsArray[i * 3] = rgb.r;
        colorsArray[i * 3 + 1] = rgb.g;
        colorsArray[i * 3 + 2] = rgb.b;
      });

      newInstancedMesh.instanceColor = new THREE.InstancedBufferAttribute(colorsArray, 3);
      newInstancedMesh.instanceMatrix.needsUpdate = true;
      newInstancedMesh.instanceColor.needsUpdate = true;
      newScene.add(newInstancedMesh);

      function animate() {
        requestAnimationFrame(animate);
        newControls.update();
        newRenderer.render(newScene, newCamera);
      }
      animate();
    }

    function drawSLAxes() {
      if (!slCtx || !slCanvas) return;
      slCtx.clearRect(0, 0, slCanvas.width, slCanvas.height);
      slCtx.strokeStyle = '#aaa';
      slCtx.lineWidth = 1;

      for (let value = 20; value <= 100; value += 20) {
        slCtx.beginPath();
        slCtx.arc(parseFloat(centerX), parseFloat(centerY), parseFloat((value / 100) * maxRadius), 0, parseFloat(2 * Math.PI));
        slCtx.stroke();
        slCtx.fillStyle = '#aaa';
        slCtx.font = '10px sans-serif';
        const labelRad = currentMode === 'donut' ? parseFloat(Math.PI / 4) : 0;
        const labelX = parseFloat(centerX + (value / 100) * maxRadius * Math.cos(parseFloat(-Math.PI / 2 + labelRad)));
        const labelY = parseFloat(centerY + (value / 100) * maxRadius * Math.sin(parseFloat(-Math.PI / 2 + labelRad)));
        slCtx.fillText(`${value}% L`, labelX, parseFloat(labelY - 5));
      }

      const maxTheta = currentMode === 'sphere' ? 180 : 90;
      const thetaStep = currentMode === 'sphere' ? 30 : 15;
      for (let theta = 0; theta <= parseFloat(maxTheta); theta += thetaStep) {
        const thetaDeg = parseFloat((theta / maxTheta) * maxTheta);
        const thetaRad = toRadians(thetaDeg);
        const rotation = currentMode === 'donut' ? parseFloat(Math.PI / 4) : 0;
        const adjustedThetaRad = parseFloat(thetaRad - Math.PI / 2 + rotation);
        slCtx.beginPath();
        slCtx.moveTo(parseFloat(centerX), parseFloat(centerY));
        slCtx.lineTo(parseFloat(centerX + maxRadius * Math.cos(adjustedThetaRad)), parseFloat(centerY + maxRadius * Math.sin(adjustedThetaRad)));
        slCtx.stroke();
        slCtx.fillStyle = '#aaa';
        slCtx.font = '10px sans-serif';
        const labelX = parseFloat(centerX + (maxRadius + 15) * Math.cos(adjustedThetaRad));
        const labelY = parseFloat(centerY + (maxRadius + 15) * Math.sin(adjustedThetaRad));
        slCtx.fillText(`${theta}° S`, parseFloat(labelX - 15), parseFloat(labelY + 5));
      }

      if (currentRelationship !== 'primary') {
        const rel = relationshipOrder.find(r => r.key === currentRelationship);
        let symbol = rel.symbol;
        if (rel.index === 0) {
          symbol += '¹';
        } else if (rel.index === 1) {
          symbol += '²';
        }
        const rotation = currentMode === 'donut' ? parseFloat(Math.PI / 4) : 0;
        const labelThetaDeg = currentMode === 'sphere' ? 90 : 45;
        const labelThetaRad = parseFloat(toRadians(labelThetaDeg) - Math.PI / 2 + rotation + Math.PI);
        slCtx.fillStyle = '#333';
        slCtx.font = '16px sans-serif';
        slCtx.textAlign = 'center';
        slCtx.textBaseline = 'middle';
        slCtx.fillText(symbol, parseFloat(centerX + (maxRadius + 20) * Math.cos(labelThetaRad)), parseFloat(centerY + (maxRadius + 20) * Math.sin(labelThetaRad)));
      }

      if (showSaturationRelationships) {
        const primaryHue = parseFloat(selectedHue);
        const rel = relationshipOrder.find(r => r.key === currentRelationship);
        const relationshipHue = parseFloat(((primaryHue + rel.offset) % 360 + 360) % 360);
        const selectedSaturation = parseFloat(document.getElementById('saturation-input').value);
        saturationRelationships.forEach(rel => {
          let s;
          if (rel.offset === 360) {
            s = selectedSaturation;
          } else if (rel.offset === 180) {
            s = parseFloat(100 - selectedSaturation);
          } else {
            s = Math.min(Math.max(parseFloat((Math.abs(rel.offset) / 180) * 100), 0), 100);
          }
          const thetaDeg = parseFloat((s / 100) * maxTheta);
          const rotation = currentMode === 'donut' ? parseFloat(Math.PI / 4) : 0;
          let adjustedThetaRad = parseFloat(toRadians(thetaDeg) - Math.PI / 2 + rotation);
          slCtx.fillStyle = '#333';
          slCtx.font = '16px sans-serif';
          slCtx.textAlign = 'center';
          slCtx.textBaseline = 'middle';
          const labelX = parseFloat(centerX + (maxRadius + 20) * Math.cos(adjustedThetaRad));
          const labelY = parseFloat(centerY + (maxRadius + 20) * Math.sin(adjustedThetaRad));
          slCtx.fillText(rel.symbol, labelX, labelY);

          if (currentRelationship !== 'primary') {
            const negThetaDeg = parseFloat(-(s / 100) * maxTheta);
            const negRotation = currentMode === 'donut' ? parseFloat(-Math.PI / 4) : 0;
            adjustedThetaRad = parseFloat(toRadians(negThetaDeg) - Math.PI / 2 + negRotation);
            const negLabelX = parseFloat(centerX + (maxRadius + 20) * Math.cos(adjustedThetaRad));
            const negLabelY = parseFloat(centerY + (maxRadius + 20) * Math.sin(adjustedThetaRad));
            slCtx.fillText(rel.symbol, negLabelX, negLabelY);
          }
        });
      }
    }

    function drawSLPoints() {
      if (!slCtx || !slCanvas) return [];
      const pointRadius = currentMode === 'sphere' ? parseFloat(BASE_POINT_RADIUS * 2) : parseFloat(BASE_POINT_RADIUS);
      const points = [];
      const relatedHues = [parseFloat(selectedHue)];
      if (currentRelationship !== 'primary') {
        const rel = relationshipOrder.find(r => r.key === currentRelationship);
        relatedHues.push(parseFloat(((parseFloat(selectedHue) + rel.offset) % 360 + 360) % 360));
      }

      const N_l_max = Math.floor(parseFloat(maxRadius / (2 * pointRadius)));
      const N_l = Math.max(1, Math.floor(parseFloat(N_l_max * rDensity)));
      for (let i = 0; i <= N_l; i++) {
        const l = parseFloat((i / N_l) * 100);
        if (l < parseFloat(minLightness) || l > parseFloat(maxLightness)) continue;
        const pixelRadius = parseFloat((l / 100) * maxRadius);
        const maxTheta = currentMode === 'sphere' ? Math.PI : parseFloat(Math.PI / 2);
        const arcLength = parseFloat(maxTheta * pixelRadius);
        const N_points = Math.floor(arcLength / (2 * pointRadius));
        let N_s = Math.max(1, Math.floor(parseFloat(N_points * thetaDensity)));
        if (pixelRadius === 0) N_s = 1;
        const deltaS = parseFloat(100 / N_s);

        for (let j = 0; j <= N_s; j++) {
          const s = parseFloat(j * deltaS);
          for (const h of relatedHues) {
            const maxThetaDeg = currentMode === 'sphere' ? 180 : 90;
            const thetaDeg = h === parseFloat(selectedHue) ? parseFloat((s / 100) * maxThetaDeg) : parseFloat(-(s / 100) * maxThetaDeg);
            const adjustedThetaDeg = h === parseFloat(selectedHue) ? thetaDeg : parseFloat(thetaDeg + 360);
            const thetaRad = toRadians(adjustedThetaDeg);
            let rotation = currentMode === 'donut' ? parseFloat(Math.PI / 4) : 0;
            rotation = currentMode === 'donut' && h !== parseFloat(selectedHue) ? parseFloat(-Math.PI / 4) : rotation;
            const adjustedThetaRad = parseFloat(thetaRad - Math.PI / 2 + rotation);
            const radius = parseFloat((l / 100) * maxRadius);
            const x = parseFloat(centerX + radius * Math.cos(adjustedThetaRad));
            const y = parseFloat(centerY + radius * Math.sin(adjustedThetaRad));
            const hex = hslToHex(h, s, l);
            const tableTheta = parseFloat((s === 0 && l === 0) ? 0 : Math.atan2(l, s) * (180 / Math.PI));
            const sqrtSL = parseFloat(Math.sqrt(s * s + l * l));
            points.push({
              code: `H${h}S${s.toFixed(2)}L${l.toFixed(2)}`,
              hex,
              h,
              s,
              l,
              theta: tableTheta,
              sqrtSL,
              thetaDeg,
              slX: x,
              slY: y,
              plotTheta: thetaDeg
            });
          }
        }
      }

      points.forEach(point => {
        const { hex, slX, slY } = point;
        slCtx.beginPath();
        slCtx.arc(slX, slY, pointRadius, 0, parseFloat(2 * Math.PI));
        slCtx.fillStyle = hex;
        slCtx.fill();
      });

      return points;
    }

    function render() {
      if (!slCanvas || !slCtx) {
        console.error('Canvas or context not initialized');
        return;
      }
      slCanvasTitle.textContent = `${UNICODE.theta} = S * ${currentMode === 'sphere' ? '180°' : '90°'} vs. L (Lightness)`;
      drawSLAxes();
      const points = drawSLPoints();
      setupThreeScene(colors, minHue, maxHue, minLightness, maxLightness);
      setupNewScene(colors, minHue, maxHue, minLightness, maxLightness, selectedHue);
      const isPrimary = currentRelationship === 'primary';
      const rel = relationshipOrder.find(r => r.key === currentRelationship);
      const relationshipHue = parseFloat(((parseFloat(selectedHue) + rel.offset) % 360 + 360) % 360);
      updateMonoHueTable(parseFloat(selectedHue), parseFloat(selectedSaturation), parseFloat(selectedLightness));
      updateMonoSineTable(parseFloat(selectedHue), parseFloat(selectedSaturation), parseFloat(selectedLightness));
      updateSaturationChart(parseFloat(selectedSaturation));
      updateSineSaturationChart(parseFloat(selectedSaturation));
      updateRelPrimaryTable(parseFloat(selectedHue), relationshipHue, isPrimary);
      updateRelRelatedTable(parseFloat(selectedHue), relationshipHue, isPrimary);

      slCanvas.onmousemove = (event) => {
        const rect = slCanvas.getBoundingClientRect();
        const mouseX = parseFloat(event.clientX - rect.left);
        const mouseY = parseFloat(event.clientY - rect.top);

        let found = false;
        points.forEach(point => {
          const { s, l, code, hex, plotTheta, theta, sqrtSL, slX, slY } = point;
          const dx = parseFloat(mouseX - slX);
          const dy = parseFloat(mouseY - slY);
          if (Math.sqrt(dx * dx + dy * dy) < (currentMode === 'sphere' ? parseFloat(BASE_POINT_RADIUS * 2) : parseFloat(BASE_POINT_RADIUS)) * 2) {
            tooltip.style.display = 'block';
            tooltip.style.left = `${event.pageX + 10}px`;
            tooltip.style.top = `${event.pageY + 10}px`;
            tooltip.textContent = `${code}\nHSL(${Math.round(parseFloat(point.h))}°, ${s.toFixed(2)}%, ${l.toFixed(2)}%)\nPlot ${UNICODE.theta}: ${plotTheta.toFixed(2)}°\nTable ${UNICODE.theta}: ${theta.toFixed(2)}°\nSqrt(S²+L²): ${sqrtSL.toFixed(2)}\n${hex.toUpperCase()}`;
            found = true;
          }
        });

        if (!found) {
          tooltip.style.display = 'none';
        }
      };

      slCanvas.onmouseout = () => {
        tooltip.style.display = 'none';
      };
    }

    function loadSampleColors() {
      statusDiv.textContent = 'Loading sample colors...';
      rDensity = parseFloat(Math.min(Math.max(parseFloat(rDensityInput.value) || 0.5, 0.1), 1));
      thetaDensity = parseFloat(Math.min(Math.max(parseFloat(thetaDensityInput.value) || 1, 0.1), 1));
      rDensityInput.value = rDensity;
      thetaDensityInput.value = thetaDensity;
      colors = [];

      const N_h_max = 72;
      const N_h = Math.max(1, Math.floor(parseFloat(N_h_max * rDensity)));
      const N_l_max = Math.floor(parseFloat(DOME_RADIUS / (2 * BASE_SPHERE_SIZE)));
      const N_l = Math.max(1, Math.floor(parseFloat(N_l_max * rDensity)));
      for (let i = 0; i <= N_h; i++) {
        const h = parseFloat((i / N_h) * 360);
        for (let j = 0; j <= N_l; j++) {
          const l = parseFloat((j / N_l) * 100);
          const pixelRadius = parseFloat((l / 100) * DOME_RADIUS);
          const arcLength = parseFloat(Math.PI * pixelRadius);
          const N_points = Math.floor(arcLength / (2 * BASE_SPHERE_SIZE));
          let N_s = Math.max(1, Math.floor(parseFloat(N_points * thetaDensity)));
          if (pixelRadius === 0) N_s = 1;
          const deltaS = parseFloat(100 / N_s);

          for (let k = 0; k <= N_s; k++) {
            const s = parseFloat(k * deltaS);
            const hex = hslToHex(h, s, l);
            const thetaDeg = parseFloat((s / 100) * (currentMode === 'sphere' ? 180 : 90));
            colors.push({
              h,
              s,
              l,
              hex,
              thetaDeg
            });
          }
        }
      }

      statusDiv.textContent = 'Ready to plot points dynamically';
      render();
    }

    document.addEventListener('DOMContentLoaded', () => {
      slCanvas = document.getElementById('slCanvas');
      slCtx = slCanvas.getContext('2d');
      centerX = parseFloat(slCanvas.width / 2);
      centerY = parseFloat(slCanvas.height / 2);
      console.log('slCtx initialized:', !!slCtx);

      const tooltip = document.getElementById('tooltip');
      const loadSampleBtn = document.getElementById('load-sample');
      const statusDiv = document.getElementById('status');
      const hueSelect = document.getElementById('hue-select');
      const saturationInput = document.getElementById('saturation-input');
      const lightnessInput = document.getElementById('lightness-input');
      const rDensityInput = document.getElementById('r-density');
      const thetaDensityInput = document.getElementById('theta-density');
      const slCanvasTitle = document.getElementById('slCanvasTitle');
      const hueSlider = document.getElementById('hue-slider');
      const hueRangeLabel = document.getElementById('hue-range-label');
      const lightnessSlider = document.getElementById('lightness-slider');
      const lightnessRangeLabel = document.getElementById('lightness-range-label');
      const showSaturationBtn = document.getElementById('show-saturation');

      noUiSlider.create(hueSlider, {
        start: [0, 359],
        connect: true,
        range: { 'min': 0, 'max': 359 },
        step: 1,
        tooltips: [false, false],
        format: {
          to: value => Math.round(parseFloat(value)) + '°',
          from: value => parseInt(value)
        }
      });

      noUiSlider.create(lightnessSlider, {
        start: [0, 100],
        connect: true,
        range: { 'min': 0, 'max': 100 },
        step: 1,
        tooltips: [false, false],
        format: {
          to: value => Math.round(parseFloat(value)) + '%',
          from: value => parseInt(value)
        }
      });

      function populateHueDropdown() {
        hueSelect.innerHTML = '<option value="">Select Hue</option>';
        for (let h = 0; h < 360; h += 5) {
          const option = document.createElement('option');
          option.value = h;
          option.textContent = `${h}°`;
          hueSelect.appendChild(option);
        }
      }

      populateHueDropdown();

      const updateScene = debounce(() => {
        setupThreeScene(colors, minHue, maxHue, minLightness, maxLightness);
        drawSLAxes();
        drawSLPoints();
        setupNewScene(colors, minHue, maxHue, minLightness, maxLightness, selectedHue);
        const isPrimary = currentRelationship === 'primary';
        const rel = relationshipOrder.find(r => r.key === currentRelationship);
        const relationshipHue = parseFloat(((parseFloat(selectedHue) + rel.offset) % 360 + 360) % 360);
        updateMonoHueTable(parseFloat(selectedHue), parseFloat(selectedSaturation), parseFloat(selectedLightness));
        updateMonoSineTable(parseFloat(selectedHue), parseFloat(selectedSaturation), parseFloat(selectedLightness));
        updateSaturationChart(parseFloat(selectedSaturation));
        updateSineSaturationChart(parseFloat(selectedSaturation));
        updateRelPrimaryTable(parseFloat(selectedHue), relationshipHue, isPrimary);
        updateRelRelatedTable(parseFloat(selectedHue), relationshipHue, isPrimary);
      }, 200);

      hueSlider.noUiSlider.on('update', (values) => {
        minHue = parseInt(values[0]);
        maxHue = parseInt(values[1]);
        hueRangeLabel.textContent = `${minHue}°–${maxHue}°`;
        updateScene();
      });

      lightnessSlider.noUiSlider.on('update', (values) => {
        minLightness = parseInt(values[0]);
        maxLightness = parseInt(values[1]);
        lightnessRangeLabel.textContent = `${minLightness}%–${maxLightness}%`;
        updateScene();
      });

      document.querySelectorAll('input[name="mode"]').forEach(radio => {
        radio.addEventListener('change', () => {
          currentMode = radio.value;
          render();
        });
      });

      document.querySelectorAll('input[name="relationship"]').forEach(radio => {
        radio.addEventListener('change', () => {
          currentRelationship = radio.value;
          render();
        });
      });

      showSaturationBtn.addEventListener('click', () => {
        showSaturationRelationships = !showSaturationRelationships;
        showSaturationBtn.textContent = showSaturationRelationships ? 'Hide Saturation Relationships' : 'Show Saturation Relationships';
        render();
      });
      hueSelect.addEventListener('change', () => {
        selectedHue = hueSelect.value;
        render();
      });

      saturationInput.addEventListener('change', () => {
        selectedSaturation = Math.min(Math.max(parseFloat(saturationInput.value) || 100, 0), 100);
        saturationInput.value = selectedSaturation;
        render();
      });

      lightnessInput.addEventListener('change', () => {
        selectedLightness = Math.min(Math.max(parseFloat(lightnessInput.value) || 50, 0), 100);
        lightnessInput.value = selectedLightness;
        render();
      });

      rDensityInput.addEventListener('change', () => {
        loadSampleColors();
      });

      thetaDensityInput.addEventListener('change', () => {
        loadSampleColors();
      });

      loadSampleBtn.addEventListener('click', loadSampleColors);

      render();
    });
  </script>
</body>
</html>