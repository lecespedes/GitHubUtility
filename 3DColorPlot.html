<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D Color Visualizer</title>
    <link rel="icon" type="image/x-icon" href="#">
    <link href=3DColorPlot.css rel=stylesheet>
  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@v0.176.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@v0.176.0/examples/jsm/"
      }
    }
  </script>
</head>
<body>
  <header>
    <h1>3D Color Visualizer</h1>
    <div id="colorSwatch"><span class="hex-text"></span></div>
  </header>
  <div class="container" id="container">
    <div class="canvas-container">
      <!-- RGB Section -->
      <div class="canvas-wrapper">
        <div class="canvas-title">
          <h2>RGB</h2>
          <div class="toggle-switch">
            <input type="checkbox" id="hPlotToggle">
            <label for="hPlotToggle"></label>
            HPlot
          </div>
          <div class="toggle-switch">
            <input type="checkbox" id="sPlotToggle">
            <label for="sPlotToggle"></label>
            SPlot
          </div>
          <div class="toggle-switch">
            <input type="checkbox" id="lPlotToggle">
            <label for="lPlotToggle"></label>
            LPlot
          </div>
        </div>
        <canvas id="rgbCanvas"></canvas>
        <div id="rgb-swatches" class="axis-swatches"></div>
        <div id="rgb-inputs" class="input-container"></div>
      </div>
      <!-- HSL Section (Cylinder Primary, Cube Secondary) -->
      <div class="canvas-wrapper">
        <div class="canvas-title">
          <h2>HSL</h2>
          <div class="controls-row">
            <div class="tab active" id="tab-cylinder">Cylinder</div>
            <div class="tab" id="tab-cube">Cube</div>
            <div class="toggle-switch">
              <input type="checkbox" id="rPlotToggle">
              <label for="rPlotToggle"></label>
              RPlot
            </div>
            <div class="toggle-switch">
              <input type="checkbox" id="gPlotToggle">
              <label for="gPlotToggle"></label>
              GPlot
            </div>
            <div class="toggle-switch">
              <input type="checkbox" id="bPlotToggle">
              <label for="bPlotToggle"></label>
              BPlot
            </div>
          </div>
        </div>
        <div class="hsl-canvas-div active" id="hsl-cylinder-div">
          <canvas id="hslCylinderCanvas"></canvas>
        </div>
        <div class="hsl-canvas-div" id="hsl-cube-div">
          <canvas id="hslCubeCanvas"></canvas>
        </div>
        <div id="hsl-swatches" class="axis-swatches"></div>
        <div id="hsl-inputs" class="input-container"></div>
      </div>
    </div>
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import WebGL from 'three/addons/capabilities/WebGL.js';

    // Global configuration
    const config = {
      CUBE_SIZE: 360,
      CYLINDER_SIZE: 300,
      CAMERA_DISTANCE_RATIO: 1.67,
      AXIS_THICKNESS: 5,
      swatchCtrlLength: 475,
      swatchCtrlStep: 2,
      AXIS_SEGMENTS: 50,
      FONT_SIZE: 96,
      DASH_SIZE: 4,
      LABEL_DISTANCE: 30,
      MARKER_RADIUS: 5,
      MARKER_LINE_DASH_SIZE: 2,
      INNER_WALL_COLOR: '#d3d3d3',
      PLOT_POINT_RADIUS: 3,
      CONE_RADIUS: 10,
      CONE_HEIGHT: 15
    };

    // Color relationships
    const colorRelationships = {
      primary: [{ offset: 0, name: 'Primary' }],
      complementary: [{ offset: 180, name: 'Complementary' }],
      splitComplementary: [
        { offset: 150, name: 'Split-Complementary' },
        { offset: 210, name: 'Split-Complementary' }
      ],
      triad: [
        { offset: 120, name: 'Triad' },
        { offset: 240, name: 'Triad' }
      ],
      tetrad: [
        { offset: 90, name: 'Tetrad' },
        { offset: 270, name: 'Tetrad' }
      ],
      adjacent: [
        { offset: 30, name: 'Adjacent' },
        { offset: -30, name: 'Adjacent' }
      ]
    };

    // Utility function for input parsing
    const parseInput = (value, max) => {
      const num = parseFloat(value);
      return isNaN(num) ? 0 : Math.max(0, Math.min(max, num));
    };

    // Abstract ColorModel class
    class ColorModel {
      constructor(canvas, width, height) {
        this.scene = new THREE.Scene();
        this.camera = null;
        this.renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        this.renderer.setSize(width || 500, height || 400);
        this.controls = null;
        this.marker = null;
        this.axesGroup = null;
        this.markerLinesGroup = null;
        this.plotGroups = {};
        this.color = null;
        this.modelManager = null;
      }

      static createAxis(start, end, colorFunc, segments = config.AXIS_SEGMENTS) {
        const axisGroup = new THREE.Group();
        for (let i = 0; i < segments; i++) {
          const t = i / (segments - 1);
          const rgb = colorFunc(t);
          const color = (rgb.r << 16) | (rgb.g << 8) | rgb.b;
          const x = start.x + t * (end.x - start.x);
          const y = start.y + t * (end.y - start.y);
          const z = start.z + t * (end.z - start.z);
          const path = new THREE.LineCurve3(
            new THREE.Vector3(x, y, z),
            new THREE.Vector3(x + (end.x - start.x) / segments, y + (end.y - start.y) / segments, z + (end.z - start.z) / segments)
          );
          const tubeGeometry = new THREE.TubeGeometry(path, 1, config.AXIS_THICKNESS, 8, false);
          const tubeMaterial = new THREE.MeshBasicMaterial({ color: color });
          const tubeSegment = new THREE.Mesh(tubeGeometry, tubeMaterial);
          axisGroup.add(tubeSegment);
        }
        return axisGroup;
      }

      static createLabel(text, position, color, fontFamily = 'Helvetica, Arial, sans-serif', fontWeight = 400, fontSize = config.FONT_SIZE) {
        const canvas = document.createElement('canvas');
        canvas.width = 256;
        canvas.height = 256;
        const context = canvas.getContext('2d');
        context.fillStyle = color;
        context.font = `${fontWeight} ${fontSize}px ${fontFamily}`;
        context.textAlign = 'left';
        context.textBaseline = 'middle';
        context.fillText(text, 10, 128);
        const texture = new THREE.CanvasTexture(canvas);
        const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
        const sprite = new THREE.Sprite(spriteMaterial);
        sprite.position.copy(position);
        sprite.scale.set(40, 40, 1);
        return sprite;
      }

      static rgbToHex(r, g, b) {
        const toHex = x => {
          const hex = Math.round(x).toString(16);
          return hex.length === 1 ? '0' + hex : hex;
        };
        return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
      }

      static hexToHSL(hex) {
        hex = hex.replace('#', '');
        let r = parseInt(hex.substring(0, 2), 16) / 255;
        let g = parseInt(hex.substring(2, 4), 16) / 255;
        let b = parseInt(hex.substring(4, 6), 16) / 255;
        let max = Math.max(r, g, b);
        let min = Math.min(r, g, b);
        let h = 0, s = 0, l = (max + min) / 2;
        if (max !== min) {
          let d = max - min;
          s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
          switch (max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
          }
          h /= 6;
        }
        h = h * 360;
        s = s * 100;
        l = l * 100;
        return { h, s, l };
      }

      static hslToRGB(h, s, l) {
        h = h / 360;
        s = s / 100;
        l = l / 100;
        let r, g, b;
        if (s === 0) {
          r = g = b = l;
        } else {
          const hue2rgb = (p, q, t) => {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;
            if (t < 1/6) return p + (q - p) * 6 * t;
            if (t < 1/2) return q;
            if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
            return p;
          };
          const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
          const p = 2 * l - q;
          r = hue2rgb(p, q, h + 1/3);
          g = hue2rgb(p, q, h);
          b = hue2rgb(p, q, h - 1/3);
        }
        return {
          r: Math.round(r * 255),
          g: Math.round(g * 255),
          b: Math.round(b * 255)
        };
      }

      initializeElements() {
        throw new Error('initializeElements must be implemented by subclass');
      }

      updateColor(color) {
        throw new Error('updateColor must be implemented by subclass');
      }

      plot(type, enabled) {
        throw new Error('plot must be implemented by subclass');
      }

      getPlotSettings() {
        throw new Error('getPlotSettings must be implemented by subclass');
      }

      setPlotSetting(type, enabled) {
        throw new Error('setPlotSetting must be implemented by subclass');
      }

      render() {
        this.renderer.render(this.scene, this.camera);
      }
    }

    // Abstract Cube class
    class Cube extends ColorModel {
      constructor(type, canvas, width, height) {
        super(canvas, width, height);
        this.type = type; // 'rgb' or 'hsl'
        this.plotSettings = {};
        this.camera = new THREE.PerspectiveCamera(45, width / height, 0.1, config.CUBE_SIZE * 5);
        this.camera.position.set(config.CUBE_SIZE, config.CYLINDER_SIZE * 1.5, config.CUBE_SIZE * 3);
        this.camera.lookAt(config.CUBE_SIZE / 2, config.CUBE_SIZE / 2, config.CUBE_SIZE / 2);
        this.camera.updateProjectionMatrix();
        this.renderer.setClearColor(0xffffff, 1);
        this.markerGeometry = new THREE.SphereGeometry(config.MARKER_RADIUS, 32, 32);
        this.markerMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        this.plotPointGeometry = new THREE.SphereGeometry(config.PLOT_POINT_RADIUS, 8, 8);
      }

      initializeElements() {
        this.controls = new OrbitControls(this.camera, this.renderer.domElement);
        this.controls.enableDamping = true;
        this.controls.dampingFactor = 0.05;
        this.controls.screenSpacePanning = true;
        this.controls.minDistance = 50;
        this.controls.maxDistance = 800;
        this.controls.target.set(config.CUBE_SIZE / 2, config.CUBE_SIZE / 2, config.CUBE_SIZE / 2);

        const cubeGeometry = new THREE.BoxGeometry(config.CUBE_SIZE, config.CUBE_SIZE, config.CUBE_SIZE);
        const cubeEdges = new THREE.EdgesGeometry(cubeGeometry);
        const innerWallMaterial = new THREE.MeshBasicMaterial({
          color: config.INNER_WALL_COLOR,
          transparent: true,
          opacity: 0.2,
          side: THREE.BackSide
        });
        const edgeMaterial = new THREE.LineDashedMaterial({
          color: 0x000000,
          linewidth: 1,
          scale: 1,
          dashSize: config.DASH_SIZE,
          gapSize: config.DASH_SIZE,
          depthWrite: false
        });

        const cubeWalls = new THREE.Mesh(cubeGeometry, innerWallMaterial);
        cubeWalls.position.set(config.CUBE_SIZE / 2, config.CUBE_SIZE / 2, config.CUBE_SIZE / 2);
        this.scene.add(cubeWalls);

        const cubeEdgesLines = new THREE.LineSegments(cubeEdges, edgeMaterial);
        cubeEdgesLines.computeLineDistances();
        cubeEdgesLines.position.set(config.CUBE_SIZE / 2, config.CUBE_SIZE / 2, config.CUBE_SIZE / 2);
        this.scene.add(cubeEdgesLines);

        this.marker = new THREE.Mesh(this.markerGeometry, this.markerMaterial);
        this.scene.add(this.marker);

        this.axesGroup = new THREE.Group();
        this.axesGroup.name = `${this.type}Axes`;
        this.scene.add(this.axesGroup);

        this.markerLinesGroup = new THREE.Group();
        this.markerLinesGroup.name = `${this.type}MarkerLines`;
        this.scene.add(this.markerLinesGroup);
      }

      updateMarkerLines() {
        this.markerLinesGroup.children.forEach(child => {
          if (child.geometry) child.geometry.dispose();
          if (child.material) child.material.dispose();
        });
        this.markerLinesGroup.clear();

        const axes = this.type === 'rgb' ? ['r', 'g', 'b'] : ['h', 's', 'l'];
        const maxCoord = config.CUBE_SIZE;
        axes.forEach((axis, index) => {
          const coord = this.marker.position.getComponent(index);
          const plane0 = 0;
          const plane1 = maxCoord;
          const dist0 = Math.abs(coord - plane0);
          const dist1 = Math.abs(coord - plane1);
          const isActive = dist0 <= dist1;
          const start = this.marker.position.clone();
          const end = this.marker.position.clone();
          if (index === 0) start.x = isActive ? plane0 : plane1;
          else if (index === 1) start.y = isActive ? plane0 : plane1;
          else start.z = isActive ? plane0 : plane1;
          if (start.distanceTo(end) > 0.001) {
            const geometry = new THREE.BufferGeometry().setFromPoints([start, end]);
            const material = new THREE.LineDashedMaterial({
              color: 0x000000,
              linewidth: 1,
              dashSize: config.MARKER_LINE_DASH_SIZE,
              gapSize: config.MARKER_LINE_DASH_SIZE
            });
            const line = new THREE.Line(geometry, material);
            line.computeLineDistances();
            this.markerLinesGroup.add(line);
          }
        });
        this.scene.add(this.markerLinesGroup);
      }
    }

    // RGBCube subclass
    class RGBCube extends Cube {
      constructor(canvas, width, height) {
        super('rgb', canvas, width, height);
        this.color = { r: 255, g: 0, b: 0 };
        this.plotSettings = { h: false, s: false, l: false };
        this.initializeElements();
        this.updateColor(this.color);
        this.render();
      }

      getPlotSettings() {
        return { ...this.plotSettings };
      }

      setPlotSetting(type, enabled) {
        if (['h', 's', 'l'].includes(type)) {
          this.plotSettings[type] = enabled;
          this.plot(type, enabled);
        }
      }

      updateColor(color) {
        this.color = { ...color };
        const hex = ColorModel.rgbToHex(color.r, color.g, color.b);
        this.markerMaterial.color.set(hex);
        this.marker.position.set(
          color.r * config.CUBE_SIZE / 255,
          color.g * config.CUBE_SIZE / 255,
          color.b * config.CUBE_SIZE / 255
        );

        // Update axes
        this.axesGroup.children.forEach(child => {
          if (child.geometry) child.geometry.dispose();
          if (child.material) child.material.dispose();
        });
        this.axesGroup.clear();

        const axisConfigs = [
          { label: 'R', end: new THREE.Vector3(config.CUBE_SIZE, 0, 0), colorFunc: t => ({ r: Math.round(t * 255), g: color.g, b: color.b }) },
          { label: 'G', end: new THREE.Vector3(0, config.CUBE_SIZE, 0), colorFunc: t => ({ r: color.r, g: Math.round(t * 255), b: color.b }) },
          { label: 'B', end: new THREE.Vector3(0, 0, config.CUBE_SIZE), colorFunc: t => ({ r: color.r, g: color.g, b: Math.round(t * 255) }) }
        ];

        axisConfigs.forEach(({ label, end, colorFunc }, index) => {
          const axis = ColorModel.createAxis(new THREE.Vector3(0, 0, 0), end, colorFunc);
          this.axesGroup.add(axis);
          const labelPos = end.clone().add(
            new THREE.Vector3(
              index === 0 ? config.LABEL_DISTANCE : 0,
              index === 1 ? config.LABEL_DISTANCE : 0,
              index === 2 ? config.LABEL_DISTANCE : 0
            )
          );
          const labelSprite = ColorModel.createLabel(label, labelPos, '#000000');
          this.axesGroup.add(labelSprite);
        });
        this.scene.add(this.axesGroup);

        this.updateMarkerLines();

        // Update plots
        ['h', 's', 'l'].forEach(type => {
          if (this.plotSettings[type]) this.plot(type, true);
        });
      }

      plot(type, enabled) {
        const groupKey = `${type}PlotGroup`;
        if (this.plotGroups[groupKey]) {
          this.plotGroups[groupKey].children.forEach(child => {
            if (child.geometry) child.geometry.dispose();
            if (child.material) child.material.dispose();
          });
          this.scene.remove(this.plotGroups[groupKey]);
          this.plotGroups[groupKey] = null;
        }
        if (!enabled) return;

        this.plotGroups[groupKey] = new THREE.Group();
        this.plotGroups[groupKey].name = `${type}PlotPoints`;
        const numSwatches = (100 / config.swatchCtrlStep) + 1;
        const { h = 0, s = 0, l = 0 } = ColorModel.hexToHSL(ColorModel.rgbToHex(this.color.r, this.color.g, this.color.b));

        if (type === 'h') {
          for (let i = 0; i < numSwatches; i++) {
            const normalizedVal = i * config.swatchCtrlStep;
            const hVal = (359 * normalizedVal) / 100;
            const rgb = ColorModel.hslToRGB(hVal, s, l);
            const material = new THREE.MeshBasicMaterial();
            material.color.setRGB(rgb.r / 255, rgb.g / 255, rgb.b / 255);
            const point = new THREE.Mesh(this.plotPointGeometry, material);
            point.position.set(
              rgb.r * config.CUBE_SIZE / 255,
              rgb.g * config.CUBE_SIZE / 255,
              rgb.b * config.CUBE_SIZE / 255
            );
            this.plotGroups[groupKey].add(point);
          }
        } else if (type === 's') {
          for (let i = 0; i < numSwatches; i++) {
            const normalizedVal = i * config.swatchCtrlStep;
            const sVal = (100 * normalizedVal) / 100;
            const rgb = ColorModel.hslToRGB(h, sVal, l);
            const material = new THREE.MeshBasicMaterial();
            material.color.setRGB(rgb.r / 255, rgb.g / 255, rgb.b / 255);
            const point = new THREE.Mesh(this.plotPointGeometry, material);
            point.position.set(
              rgb.r * config.CUBE_SIZE / 255,
              rgb.g * config.CUBE_SIZE / 255,
              rgb.b * config.CUBE_SIZE / 255
            );
            this.plotGroups[groupKey].add(point);
          }
        } else if (type === 'l') {
          for (let i = 0; i < numSwatches; i++) {
            const normalizedVal = i * config.swatchCtrlStep;
            const lVal = (100 * normalizedVal) / 100;
            const rgb = ColorModel.hslToRGB(h, s, lVal);
            const material = new THREE.MeshBasicMaterial();
            material.color.setRGB(rgb.r / 255, rgb.g / 255, rgb.b / 255);
            const point = new THREE.Mesh(this.plotPointGeometry, material);
            point.position.set(
              rgb.r * config.CUBE_SIZE / 255,
              rgb.g * config.CUBE_SIZE / 255,
              rgb.b * config.CUBE_SIZE / 255
            );
            this.plotGroups[groupKey].add(point);
          }
        }
        this.scene.add(this.plotGroups[groupKey]);
      }
    }

    // HSLCube subclass
    class HSLCube extends Cube {
      constructor(canvas, width, height) {
        super('hsl', canvas, width, height);
        this.color = { h: 0, s: 100, l: 50 };
        this.plotSettings = { r: false, g: false, b: false };
        this.initializeElements();
        this.updateColor(this.color);
        this.render();
      }

      getPlotSettings() {
        return { ...this.plotSettings };
      }

      setPlotSetting(type, enabled) {
        if (['r', 'g', 'b'].includes(type)) {
          this.plotSettings[type] = enabled;
          this.plot(type, enabled);
        }
      }

      updateColor(color) {
        this.color = { ...color };
        const hex = ColorModel.rgbToHex(
          ColorModel.hslToRGB(color.h, color.s, color.l).r,
          ColorModel.hslToRGB(color.h, color.s, color.l).g,
          ColorModel.hslToRGB(color.h, color.s, color.l).b
        );
        this.markerMaterial.color.set(hex);
        this.marker.position.set(
          color.h * config.CUBE_SIZE / 359,
          color.s * config.CUBE_SIZE / 100,
          color.l * config.CUBE_SIZE / 100
        );

        // Update axes
        this.axesGroup.children.forEach(child => {
          if (child.geometry) child.geometry.dispose();
          if (child.material) child.material.dispose();
        });
        this.axesGroup.clear();

        const axisConfigs = [
          { label: 'H', end: new THREE.Vector3(config.CUBE_SIZE, 0, 0), colorFunc: t => ColorModel.hslToRGB(t * 359, color.s, color.l) },
          { label: 'S', end: new THREE.Vector3(0, config.CUBE_SIZE, 0), colorFunc: t => ColorModel.hslToRGB(color.h, t * 100, color.l) },
          { label: 'L', end: new THREE.Vector3(0, 0, config.CUBE_SIZE), colorFunc: t => ColorModel.hslToRGB(color.h, color.s, t * 100) }
        ];

        axisConfigs.forEach(({ label, end, colorFunc }, index) => {
          const axis = ColorModel.createAxis(new THREE.Vector3(0, 0, 0), end, colorFunc);
          this.axesGroup.add(axis);
          const labelPos = end.clone().add(
            new THREE.Vector3(
              index === 0 ? config.LABEL_DISTANCE : 0,
              index === 1 ? config.LABEL_DISTANCE : 0,
              index === 2 ? config.LABEL_DISTANCE : 0
            )
          );
          const labelSprite = ColorModel.createLabel(label, labelPos, '#000000');
          this.axesGroup.add(labelSprite);
        });
        this.scene.add(this.axesGroup);

        this.updateMarkerLines();

        // Update plots
        ['r', 'g', 'b'].forEach(type => {
          if (this.plotSettings[type]) this.plot(type, true);
        });
      }

      plot(type, enabled) {
        const groupKey = `${type}PlotGroup`;
        if (this.plotGroups[groupKey]) {
          this.plotGroups[groupKey].children.forEach(child => {
            if (child.geometry) child.geometry.dispose();
            if (child.material) child.material.dispose();
          });
          this.scene.remove(this.plotGroups[groupKey]);
          this.plotGroups[groupKey] = null;
        }
        if (!enabled) return;

        this.plotGroups[groupKey] = new THREE.Group();
        this.plotGroups[groupKey].name = `${type}PlotPoints`;
        const numSwatches = (100 / config.swatchCtrlStep) + 1;
        const rgb = ColorModel.hslToRGB(this.color.h, this.color.s, this.color.l);
        const { r = 0, g = 0, b = 0 } = rgb;

        if (type === 'r') {
          for (let i = 0; i < numSwatches; i++) {
            const normalizedVal = i * config.swatchCtrlStep;
            const rVal = (255 * normalizedVal) / 100;
            const hex = ColorModel.rgbToHex(Math.round(rVal), Math.round(g), Math.round(b));
            const hsl = ColorModel.hexToHSL(hex);
            const material = new THREE.MeshBasicMaterial();
            material.color.setRGB(rVal / 255, g / 255, b / 255);
            const point = new THREE.Mesh(this.plotPointGeometry, material);
            point.position.set(
              parseFloat(hsl.h) * config.CUBE_SIZE / 359,
              parseFloat(hsl.s) * config.CUBE_SIZE / 100,
              parseFloat(hsl.l) * config.CUBE_SIZE / 100
            );
            this.plotGroups[groupKey].add(point);
          }
        } else if (type === 'g') {
          for (let i = 0; i < numSwatches; i++) {
            const normalizedVal = i * config.swatchCtrlStep;
            const gVal = (255 * normalizedVal) / 100;
            const hex = ColorModel.rgbToHex(Math.round(r), Math.round(gVal), Math.round(b));
            const hsl = ColorModel.hexToHSL(hex);
            const material = new THREE.MeshBasicMaterial();
            material.color.setRGB(r / 255, gVal / 255, b / 255);
            const point = new THREE.Mesh(this.plotPointGeometry, material);
            point.position.set(
              parseFloat(hsl.h) * config.CUBE_SIZE / 359,
              parseFloat(hsl.s) * config.CUBE_SIZE / 100,
              parseFloat(hsl.l) * config.CUBE_SIZE / 100
            );
            this.plotGroups[groupKey].add(point);
          }
        } else if (type === 'b') {
          for (let i = 0; i < numSwatches; i++) {
            const normalizedVal = i * config.swatchCtrlStep;
            const bVal = (255 * normalizedVal) / 100;
            const hex = ColorModel.rgbToHex(Math.round(r), Math.round(g), Math.round(bVal));
            const hsl = ColorModel.hexToHSL(hex);
            const material = new THREE.MeshBasicMaterial();
            material.color.setRGB(r / 255, g / 255, bVal / 255);
            const point = new THREE.Mesh(this.plotPointGeometry, material);
            point.position.set(
              parseFloat(hsl.h) * config.CUBE_SIZE / 359,
              parseFloat(hsl.s) * config.CUBE_SIZE / 100,
              parseFloat(hsl.l) * config.CUBE_SIZE / 100
            );
            this.plotGroups[groupKey].add(point);
          }
        }
        this.scene.add(this.plotGroups[groupKey]);
      }
    }

    // Cylinder subclass
    class Cylinder extends ColorModel {
      constructor(canvas, width, height) {
        super(canvas, width, height);
        this.color = { h: 0, s: 100, l: 50 };
        this.plotSettings = { r: false, g: false, b: false, h: true };
        this.camera = new THREE.PerspectiveCamera(45, width / height, 0.1, config.CYLINDER_SIZE * 5);
        this.camera.position.set(config.CYLINDER_SIZE, config.CYLINDER_SIZE * 2, config.CYLINDER_SIZE * 2.5);
        this.camera.lookAt(0, config.CYLINDER_SIZE / 2, 0);
        this.camera.updateProjectionMatrix();
        this.renderer.setClearColor(0xffffff, 1);
        this.markerGeometry = new THREE.SphereGeometry(config.MARKER_RADIUS, 32, 32);
        this.markerMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        this.plotPointGeometry = new THREE.SphereGeometry(config.PLOT_POINT_RADIUS, 8, 8);
        this.coneGeometry = new THREE.ConeGeometry(config.CONE_RADIUS, config.CONE_HEIGHT, 32);
        this.shapeMaterial = new THREE.LineBasicMaterial({ color: 0x999999, linewidth: 1 });
        this.hueLabelsGroup = null;
        this.relationshipGroups = {};
        this.tetradSquare = null;
        this.triadTriangle = null;
        this.raycaster = null;
        this.mouse = null;
        this.initializeElements();
        this.initializeMouseEvents();
        this.updateColor(this.color);
        this.render();
      }

      getPlotSettings() {
        return { ...this.plotSettings };
      }

      setPlotSetting(type, enabled) {
        if (['r', 'g', 'b'].includes(type)) {
          this.plotSettings[type] = enabled;
          this.plot(type, enabled);
        }
        // H plot is always on
      }

      initializeElements() {
        this.controls = new OrbitControls(this.camera, this.renderer.domElement);
        this.controls.enableDamping = true;
        this.controls.dampingFactor = 0.05;
        this.controls.screenSpacePanning = true;
        this.controls.minDistance = 50;
        this.controls.maxDistance = 1000;
        this.controls.target.set(0, config.CYLINDER_SIZE / 2, 0);

        const innerWallMaterial = new THREE.MeshBasicMaterial({
          color: config.INNER_WALL_COLOR,
          transparent: true,
          opacity: 0.2,
          side: THREE.BackSide
        });
        const edgeMaterial = new THREE.LineDashedMaterial({
          color: 0x000000,
          linewidth: 1,
          scale: 1,
          dashSize: config.DASH_SIZE,
          gapSize: config.DASH_SIZE,
          depthWrite: false
        });

        const cylinderGeometry = new THREE.CylinderGeometry(config.CYLINDER_SIZE, config.CYLINDER_SIZE, config.CYLINDER_SIZE, 24, 1, true);
        const cylinderEdges = new THREE.EdgesGeometry(cylinderGeometry);
        const cylinderCapsGeometry = new THREE.CylinderGeometry(config.CYLINDER_SIZE, config.CYLINDER_SIZE, 0.1, 24);
        const cylinderCapsWireframe = new THREE.WireframeGeometry(cylinderCapsGeometry);

        const hslCylinderWalls = new THREE.Mesh(cylinderGeometry, innerWallMaterial);
        hslCylinderWalls.position.set(0, config.CYLINDER_SIZE / 2, 0);
        this.scene.add(hslCylinderWalls);

        const hslCylinderWireFrameTop = new THREE.LineSegments(cylinderCapsWireframe, edgeMaterial);
        hslCylinderWireFrameTop.computeLineDistances();
        hslCylinderWireFrameTop.position.set(0, config.CYLINDER_SIZE, 0);
        this.scene.add(hslCylinderWireFrameTop);

        const hslCylinderWireFrameBottom = new THREE.LineSegments(cylinderCapsWireframe, edgeMaterial);
        hslCylinderWireFrameBottom.computeLineDistances();
        hslCylinderWireFrameBottom.position.set(0, 0, 0);
        this.scene.add(hslCylinderWireFrameBottom);

        const hslCylinderWallEdges = new THREE.LineSegments(cylinderEdges, edgeMaterial);
        hslCylinderWallEdges.computeLineDistances();
        hslCylinderWallEdges.position.set(0, config.CYLINDER_SIZE / 2, 0);
        this.scene.add(hslCylinderWallEdges);

        this.hueLabelsGroup = new THREE.Group();
        this.hueLabelsGroup.name = 'hueLabels';
        for (let angle = 15; angle < 360; angle += 15) {
          const theta = (angle * Math.PI) / 180;
          const labelPos = new THREE.Vector3(
            310 * Math.cos(theta),
            0,
            310 * Math.sin(theta)
          );
          const label = ColorModel.createLabel(angle.toString(), labelPos, '#000000');
          this.hueLabelsGroup.add(label);
        }
        this.scene.add(this.hueLabelsGroup);

        Object.keys(colorRelationships).forEach(relKey => {
          this.relationshipGroups[relKey] = new THREE.Group();
          this.relationshipGroups[relKey].name = `${relKey}Markers`;
          this.relationshipGroups[relKey].position.set(0, 0, 0);
          colorRelationships[relKey].forEach((rel, index) => {
            const isPrimary = relKey === 'primary';
            const geometry = isPrimary
              ? new THREE.OctahedronGeometry(config.CONE_RADIUS)
              : this.coneGeometry;
            const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
            const marker = new THREE.Mesh(geometry, material);
            if (!isPrimary) marker.rotation.x = Math.PI;
            const theta = (rel.offset * Math.PI) / 180;
           marker.position.set(
              config.CYLINDER_SIZE * Math.cos(theta),
              config.CYLINDER_SIZE + 45,
              config.CYLINDER_SIZE * Math.sin(theta)
            );
            marker.userData = { relationship: rel.name, offset: rel.offset };
            this.relationshipGroups[relKey].add(marker);
          });
          this.scene.add(this.relationshipGroups[relKey]);
        });

        this.tetradSquare = new THREE.Group();
        this.tetradSquare.name = 'tetradSquare';
        this.scene.add(this.tetradSquare);

        this.triadTriangle = new THREE.Group();
        this.triadTriangle.name = 'triadTriangle';
        this.scene.add(this.triadTriangle);

        const originGeometry = new THREE.SphereGeometry(config.MARKER_RADIUS, 8, 8);
        const originMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
        const originMarker = new THREE.Mesh(originGeometry, originMaterial);
        originMarker.position.set(0, 0, 0);
        this.scene.add(originMarker);

        this.marker = new THREE.Mesh(this.markerGeometry, this.markerMaterial);
        this.scene.add(this.marker);

        this.axesGroup = new THREE.Group();
        this.axesGroup.name = 'hslCylinderAxes';
        this.scene.add(this.axesGroup);

        this.markerLinesGroup = new THREE.Group();
        this.markerLinesGroup.name = 'hslCylinderMarkerLines';
        this.scene.add(this.markerLinesGroup);
        // Create and append tooltip element
        this.tooltip = document.createElement('div');
        this.tooltip.id = 'tooltip';
        Object.assign(this.tooltip.style, {
          position: 'absolute',
          backgroundColor: 'white',
          border: '1px solid #333',
          borderRadius: '4px',
          padding: '5px 10px',
          fontSize: '0.9rem',
          pointerEvents: 'none',
          display: 'none',
          zIndex: '1000',
          textAlign: 'center',
          whiteSpace: 'pre-line'
        });
        document.body.appendChild(this.tooltip);
      }

      initializeMouseEvents() {
  this.raycaster = new THREE.Raycaster();
  this.mouse = new THREE.Vector2();
  this.renderer.domElement.addEventListener('mousemove', (event) => {
    event.preventDefault();
    if (!this.tooltip || this.renderer.domElement.style.display === 'none') return; // Guard against missing tooltip or hidden canvas

    const rect = this.renderer.domElement.getBoundingClientRect();
    this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
    this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

    this.raycaster.setFromCamera(this.mouse, this.camera);
    let intersected = false;
    for (const relKey in this.relationshipGroups) {
      const intersects = this.raycaster.intersectObject(this.relationshipGroups[relKey], true);
      if (intersects.length > 0) {
        const mesh = intersects[0].object;
        const relHue = (this.color.h + mesh.userData.offset) % 360;
        const relRGB = ColorModel.hslToRGB(relHue, this.color.s, this.color.l);
        const relHex = ColorModel.rgbToHex(relRGB.r, relRGB.g, relRGB.b);
        this.tooltip.textContent = `${mesh.userData.relationship}\n(${relHex.toUpperCase()})`;
        this.tooltip.style.display = 'block';

        const tooltipWidth = this.tooltip.offsetWidth;
        const tooltipHeight = this.tooltip.offsetHeight;
        const offset = 10;
        const x = event.clientX - tooltipWidth / 2;
        const y = event.clientY - tooltipHeight - offset;

        this.tooltip.style.left = `${x}px`;
        this.tooltip.style.top = `${y}px`;

        intersected = true;
        break;
      }
    }
    if (!intersected) {
      this.tooltip.style.display = 'none';
    }
  });
}

      updateColor(color) {
        this.color = { ...color };
        const hex = ColorModel.rgbToHex(
          ColorModel.hslToRGB(color.h, color.s, color.l).r,
          ColorModel.hslToRGB(color.h, color.s, color.l).g,
          ColorModel.hslToRGB(color.h, color.s, color.l).b
        );
        this.markerMaterial.color.set(hex);
        const hRad = (color.h * Math.PI * 2) / 360;
        const s = color.s * config.CYLINDER_SIZE / 100;
        this.marker.position.set(
          s * Math.cos(hRad),
          color.l * config.CYLINDER_SIZE / 100,
          s * Math.sin(hRad)
        );

        Object.keys(this.relationshipGroups).forEach(relKey => {
          this.relationshipGroups[relKey].children.forEach((cone, index) => {
            const offset = colorRelationships[relKey][index].offset;
            const relHue = (color.h + offset) % 360;
            const relRGB = ColorModel.hslToRGB(relHue, color.s, color.l);
            const relColor = (relRGB.r << 16) | (relRGB.g << 8) | relRGB.b;
            const theta = (relHue * Math.PI) / 180;
            const relPos = new THREE.Vector3(
              config.CYLINDER_SIZE * Math.cos(theta),
              config.CYLINDER_SIZE + 45,
              config.CYLINDER_SIZE * Math.sin(theta)
            );
            cone.material.color.set(relColor);
            cone.position.copy(relPos);
          });
        });

        this.tetradSquare.children.forEach(child => {
          if (child.geometry) child.geometry.dispose();
          if (child.material) child.material.dispose();
        });
        this.tetradSquare.clear();
        this.tetradSquare = new THREE.Group();
        this.tetradSquare.name = 'tetradSquare';
        const tetradOffsets = [
          colorRelationships.primary[0].offset,
          colorRelationships.tetrad[0].offset,
          colorRelationships.complementary[0].offset,
          colorRelationships.tetrad[1].offset
        ];
        const tetradPoints = tetradOffsets.map(offset => {
          const relHue = (color.h + offset) % 360;
          const theta = (relHue * Math.PI) / 180;
          return new THREE.Vector3(
            config.CYLINDER_SIZE * Math.cos(theta),
            config.CYLINDER_SIZE + 45,
            config.CYLINDER_SIZE * Math.sin(theta)
          );
        });
        const squareGeometry = new THREE.BufferGeometry().setFromPoints(tetradPoints);
        const square = new THREE.LineLoop(squareGeometry, this.shapeMaterial);
        square.computeLineDistances();
        this.tetradSquare.add(square);
        this.scene.add(this.tetradSquare);

        this.triadTriangle.children.forEach(child => {
          if (child.geometry) child.geometry.dispose();
          if (child.material) child.material.dispose();
        });
        this.triadTriangle.clear();
        this.triadTriangle = new THREE.Group();
        this.triadTriangle.name = 'triadTriangle';
        const triadOffsets = [
          colorRelationships.primary[0].offset,
          colorRelationships.triad[0].offset,
          colorRelationships.triad[1].offset
        ];
        const triadPoints = triadOffsets.map(offset => {
          const relHue = (color.h + offset) % 360;
          const theta = (relHue * Math.PI) / 180;
          return new THREE.Vector3(
            config.CYLINDER_SIZE * Math.cos(theta),
            config.CYLINDER_SIZE + 45,
            config.CYLINDER_SIZE * Math.sin(theta)
          );
        });
        const triangleGeometry = new THREE.BufferGeometry().setFromPoints(triadPoints);
        const triangle = new THREE.LineLoop(triangleGeometry, this.shapeMaterial);
        triangle.computeLineDistances();
        this.triadTriangle.add(triangle);
        this.scene.add(this.triadTriangle);

        this.axesGroup.children.forEach(child => {
          if (child.geometry) child.geometry.dispose();
          if (child.material) child.material.dispose();
        });
        this.axesGroup.clear();
        this.axesGroup = new THREE.Group();
        this.axesGroup.name = 'hslCylinderAxes';
        const axisConfigs = [
          { label: 'S', end: new THREE.Vector3(config.CYLINDER_SIZE, 0, 0), colorFunc: t => ColorModel.hslToRGB(color.h, t * 100, color.l) },
          { label: 'L', end: new THREE.Vector3(0, config.CYLINDER_SIZE, 0), colorFunc: t => ColorModel.hslToRGB(color.h, color.s, t * 100) }
        ];
        axisConfigs.forEach(({ label, end, colorFunc }, index) => {
          const axis = ColorModel.createAxis(new THREE.Vector3(0, 0, 0), end, colorFunc);
          this.axesGroup.add(axis);
          const labelPos = end.clone().add(
            new THREE.Vector3(index === 0 ? config.LABEL_DISTANCE : 0, index === 1 ? config.LABEL_DISTANCE : 0, 0)
          );
          const labelSprite = ColorModel.createLabel(label, labelPos, '#000000');
          this.axesGroup.add(labelSprite);
        });
        this.scene.add(this.axesGroup);

        this.markerLinesGroup.children.forEach(child => {
          if (child.geometry) child.geometry.dispose();
          if (child.material) child.material.dispose();
        });
        this.markerLinesGroup.clear();
        this.markerLinesGroup = new THREE.Group();
        this.markerLinesGroup.name = 'hslCylinderMarkerLines';

        const lDistToFloor = Math.abs(this.marker.position.y - 0);
        const lDistToCeiling = Math.abs(this.marker.position.y - config.CYLINDER_SIZE);
        const lTargetY = lDistToFloor <= lDistToCeiling ? 0 : config.CYLINDER_SIZE;
        const lStart = this.marker.position.clone();
        const lEnd = new THREE.Vector3(this.marker.position.x, lTargetY, this.marker.position.z);
        if (lStart.distanceTo(lEnd) > 0.001) {
          const geometry = new THREE.BufferGeometry().setFromPoints([lStart, lEnd]);
          const material = new THREE.LineDashedMaterial({
            color: 0x000000,
            linewidth: 1,
            dashSize: config.MARKER_LINE_DASH_SIZE,
            gapSize: config.MARKER_LINE_DASH_SIZE
          });
          const line = new THREE.Line(geometry, material);
          line.computeLineDistances();
          this.markerLinesGroup.add(line);
        }

        const distToOrigin = Math.sqrt(this.marker.position.x * this.marker.position.x + this.marker.position.z * this.marker.position.z);
        const sMax = config.CYLINDER_SIZE;
        const wallX = sMax * Math.cos(hRad);
        const wallZ = sMax * Math.sin(hRad);
        const distToWall = Math.sqrt((this.marker.position.x - wallX) ** 2 + (this.marker.position.z - wallZ) ** 2);
        const sStart = this.marker.position.clone();
        let sEnd;
        if (distToOrigin <= distToWall) {
          sEnd = new THREE.Vector3(0, this.marker.position.y, 0);
        } else {
          sEnd = new THREE.Vector3(wallX, this.marker.position.y, wallZ);
        }
        if (sStart.distanceTo(sEnd) > 0.001) {
          const geometry = new THREE.BufferGeometry().setFromPoints([sStart, sEnd]);
          const material = new THREE.LineDashedMaterial({
            color: 0x000000,
            linewidth: 1,
            dashSize: config.MARKER_LINE_DASH_SIZE,
            gapSize: config.MARKER_LINE_DASH_SIZE
          });
          const line = new THREE.Line(geometry, material);
          line.computeLineDistances();
          this.markerLinesGroup.add(line);
        }
        this.scene.add(this.markerLinesGroup);

        // Update plots
        ['r', 'g', 'b', 'h'].forEach(type => {
          if (this.plotSettings[type]) this.plot(type, true);
        });
      }

      plot(type, enabled) {
        const groupKey = `${type}PlotGroup`;
        if (this.plotGroups[groupKey]) {
          this.plotGroups[groupKey].children.forEach(child => {
            if (child.geometry) child.geometry.dispose();
            if (child.material) child.material.dispose();
          });
          this.scene.remove(this.plotGroups[groupKey]);
          this.plotGroups[groupKey] = null;
        }
        if (!enabled) return;

        this.plotGroups[groupKey] = new THREE.Group();
        this.plotGroups[groupKey].name = `${type}PlotPoints`;
        const numSwatches = (100 / config.swatchCtrlStep) + 1;
        const rgb = ColorModel.hslToRGB(this.color.h, this.color.s, this.color.l);
        const { r = 0, g = 0, b = 0 } = rgb;

        if (type === 'r') {
          for (let i = 0; i < numSwatches; i++) {
            const normalizedVal = i * config.swatchCtrlStep;
            const rVal = (255 * normalizedVal) / 100;
            const hex = ColorModel.rgbToHex(Math.round(rVal), Math.round(g), Math.round(b));
            const hsl = ColorModel.hexToHSL(hex);
            const material = new THREE.MeshBasicMaterial();
            material.color.setRGB(rVal / 255, g / 255, b / 255);
            const point = new THREE.Mesh(this.plotPointGeometry, material);
            const hRad = (parseFloat(hsl.h) * Math.PI * 2) / 360;
            const sScaled = parseFloat(hsl.s) * config.CYLINDER_SIZE / 100;
            point.position.set(
              sScaled * Math.cos(hRad),
              parseFloat(hsl.l) * config.CYLINDER_SIZE / 100,
              sScaled * Math.sin(hRad)
            );
            this.plotGroups[groupKey].add(point);
          }
        } else if (type === 'g') {
          for (let i = 0; i < numSwatches; i++) {
            const normalizedVal = i * config.swatchCtrlStep;
            const gVal = (255 * normalizedVal) / 100;
            const hex = ColorModel.rgbToHex(Math.round(r), Math.round(gVal), Math.round(b));
            const hsl = ColorModel.hexToHSL(hex);
            const material = new THREE.MeshBasicMaterial();
            material.color.setRGB(r / 255, gVal / 255, b / 255);
            const point = new THREE.Mesh(this.plotPointGeometry, material);
            const hRad = (parseFloat(hsl.h) * Math.PI * 2) / 360;
            const sScaled = parseFloat(hsl.s) * config.CYLINDER_SIZE / 100;
            point.position.set(
              sScaled * Math.cos(hRad),
              parseFloat(hsl.l) * config.CYLINDER_SIZE / 100,
              sScaled * Math.sin(hRad)
            );
            this.plotGroups[groupKey].add(point);
          }
        } else if (type === 'b') {
          for (let i = 0; i < numSwatches; i++) {
            const normalizedVal = i * config.swatchCtrlStep;
            const bVal = (255 * normalizedVal) / 100;
            const hex = ColorModel.rgbToHex(Math.round(r), Math.round(g), Math.round(bVal));
            const hsl = ColorModel.hexToHSL(hex);
            const material = new THREE.MeshBasicMaterial();
            material.color.setRGB(r / 255, g / 255, bVal / 255);
            const point = new THREE.Mesh(this.plotPointGeometry, material);
            const hRad = (parseFloat(hsl.h) * Math.PI * 2) / 360;
            const sScaled = parseFloat(hsl.s) * config.CYLINDER_SIZE / 100;
            point.position.set(
              sScaled * Math.cos(hRad),
              parseFloat(hsl.l) * config.CYLINDER_SIZE / 100,
              sScaled * Math.sin(hRad)
            );
            this.plotGroups[groupKey].add(point);
          }
        } else if (type === 'h') {
          for (let i = 0; i < numSwatches; i++) {
            const normalizedVal = i * config.swatchCtrlStep;
            const hVal = (359 * normalizedVal) / 100;
            const rgb = ColorModel.hslToRGB(hVal, this.color.s, this.color.l);
            const material = new THREE.MeshBasicMaterial();
            material.color.setRGB(rgb.r / 255, rgb.g / 255, rgb.b / 255);
            const point = new THREE.Mesh(this.plotPointGeometry, material);
            const hRad = (hVal * Math.PI * 2) / 360;
            const sScaled = this.color.s * config.CYLINDER_SIZE / 100;
            const lScaled = this.color.l * config.CYLINDER_SIZE / 100;
            point.position.set(
              sScaled * Math.cos(hRad),
              lScaled,
              sScaled * Math.sin(hRad)
            );
            this.plotGroups[groupKey].add(point);
          }
        }
        this.scene.add(this.plotGroups[groupKey]);
      }
    }

    // ModelManager
    class ModelManager {
      constructor() {
        this.models = new Map();
        this.state = { rgb: { r: 255, g: 0, b: 0 }, hsl: { h: 0, s: 100, l: 50 } };
        this.dom = { 
          colorSwatch: null,
        };
        this.swatchControlsElements = { rgb: null, hsl: null };
        this.inputControlsElements = { rgb: null, hsl: null };
      }

      registerModel(id, model, width, height) {
        model.modelManager = this;
        this.models.set(id, { model, width, height });
      }

      update() {
        this.models.forEach(({ model }) => {
          if (model instanceof RGBCube) {
            model.updateColor(this.state.rgb);
          } else {
            model.updateColor(this.state.hsl);
          }
        });
      }

      animate() {
        try {
          requestAnimationFrame(this.animate.bind(this));
          this.models.forEach(({ model }) => {
            // Skip rendering if canvas is not visible
          if (model.renderer.domElement.style.display === 'none') {
            return;
          }
          model.controls.update();
          model.render();
          });
        } catch (e) {
          console.error("Rendering failed:", e.message);
        }
      }

      updateFromInput(mode) {
        const values = {
          r: parseInput(this.inputControlsElements.rgb?.querySelector('.input-r')?.value || this.state.rgb.r, 255),
          g: parseInput(this.inputControlsElements.rgb?.querySelector('.input-g')?.value || this.state.rgb.g, 255),
          b: parseInput(this.inputControlsElements.rgb?.querySelector('.input-b')?.value || this.state.rgb.b, 255),
          h: parseInput(this.inputControlsElements.hsl?.querySelector('.input-h')?.value || this.state.hsl.h, 359),
          s: parseInput(this.inputControlsElements.hsl?.querySelector('.input-s')?.value || this.state.hsl.s, 100),
          l: parseInput(this.inputControlsElements.hsl?.querySelector('.input-l')?.value || this.state.hsl.l, 100)
        };
        let hex;
        if (mode === 'rgb') {
          this.state.rgb = { r: values.r, g: values.g, b: values.b };
          hex = ColorModel.rgbToHex(values.r, values.g, values.b);
          this.state.hsl = ColorModel.hexToHSL(hex);
          this.state.hsl.h = parseFloat(this.state.hsl.h);
          if (isNaN(this.state.hsl.h)) this.state.hsl.h = values.h;
        } else {
          this.state.hsl = { h: values.h, s: values.s, l: values.l };
          this.state.rgb = ColorModel.hslToRGB(values.h, values.s, values.l);
          hex = ColorModel.rgbToHex(this.state.rgb.r, this.state.rgb.g, this.state.rgb.b);
        }

        if (this.inputControlsElements.rgb) {
          this.inputControlsElements.rgb.querySelector('.input-r').value = this.state.rgb.r;
          this.inputControlsElements.rgb.querySelector('.input-g').value = this.state.rgb.g;
          this.inputControlsElements.rgb.querySelector('.input-b').value = this.state.rgb.b;
        }
        if (this.inputControlsElements.hsl) {
          this.inputControlsElements.hsl.querySelector('.input-h').value = Math.round(this.state.hsl.h);
          this.inputControlsElements.hsl.querySelector('.input-s').value = Math.round(this.state.hsl.s);
          this.inputControlsElements.hsl.querySelector('.input-l').value = Math.round(this.state.hsl.l);
        }

        if (this.dom.colorSwatch) {
          const hsl = ColorModel.hexToHSL(hex);
          const swatchLightness = parseFloat(hsl.l);
          const textLightness = swatchLightness > 70 ? 0 : 100;
          const textRGB = ColorModel.hslToRGB(0, 0, textLightness);
          this.dom.colorSwatch.style.backgroundColor = hex;
          this.dom.colorSwatch.querySelector('.hex-text').textContent = hex.toUpperCase();
          this.dom.colorSwatch.querySelector('.hex-text').style.color = ColorModel.rgbToHex(textRGB.r, textRGB.g, textRGB.b);
        }

        this.updateSwatches();
        this.update();
      }

      swatchControls(type, element) {
        element.innerHTML = '';
        this.swatchControlsElements[type] = element;
        const components = type === 'rgb' ? ['r', 'g', 'b'] : ['h', 's', 'l'];
        const scales = type === 'rgb' ? [255, 255, 255] : [359, 100, 100];
        const labels = type === 'rgb' ? ['R', 'G', 'B'] : ['H', 'S', 'L'];

        components.forEach((comp, index) => {
          const group = document.createElement('div');
          group.className = 'axis-swatch-group';
          const label = document.createElement('label');
          label.textContent = labels[index];
          const swatchLine = document.createElement('div');
          swatchLine.className = `swatch-line swatch-${comp}`;
          swatchLine.style.width = `${config.swatchCtrlLength}px`;
          group.appendChild(label);
          group.appendChild(swatchLine);
          element.appendChild(group);
        });

        this.updateSwatches();

        components.forEach(comp => {
          const swatchLine = element.querySelector(`.swatch-${comp}`);
          swatchLine.addEventListener('click', event => {
            if (event.target.classList.contains('swatch')) {
              const value = event.target.dataset[comp];
              const input = this.inputControlsElements[type]?.querySelector(`.input-${comp}`);
              if (input) {
                input.value = value;
                this.updateFromInput(type);
              }
            }
          });
        });
      }

      inputControls(type, element) {
        element.innerHTML = '';
        this.inputControlsElements[type] = element;
        const components = type === 'rgb' ? ['r', 'g', 'b'] : ['h', 's', 'l'];
        const labels = type === 'rgb' ? ['Red', 'Green', 'Blue'] : ['Hue', 'Saturation', 'Lightness'];
        const maxValues = type === 'rgb' ? [255, 255, 255] : [359, 100, 100];
        const ranges = type === 'rgb' ? ['(0255)', '(0255)', '(0255)'] : ['(0359)', '(0100%)', '(0100%)'];

        components.forEach((comp, index) => {
          const group = document.createElement('div');
          group.className = 'input-group';
          const label = document.createElement('label');
          label.textContent = labels[index];
          const input = document.createElement('input');
          input.type = 'number';
          input.className = `input-${comp}`;
          input.min = '0';
          input.max = maxValues[index];
          input.value = type === 'rgb' ? this.state.rgb[comp] : this.state.hsl[comp];
          input.addEventListener('input', () => this.updateFromInput(type));
          const range = document.createTextNode(ranges[index]);
          group.appendChild(label);
          group.appendChild(input);
          group.appendChild(range);
          element.appendChild(group);
        });
      }

      currentSwatch(element) {
        this.dom.colorSwatch = element;
        this.updateFromInput('rgb');
      }

      updateSwatches() {
        const values = {
          r: this.state.rgb.r,
          g: this.state.rgb.g,
          b: this.state.rgb.b,
          h: this.state.hsl.h,
          s: this.state.hsl.s,
          l: this.state.hsl.l
        };

        const swatchCtrlLength = Math.max(100, config.swatchCtrlLength);
        const numSwatches = (100 / config.swatchCtrlStep) + 1;
        const swatchWidth = Math.round(swatchCtrlLength / numSwatches);

        ['rgb', 'hsl'].forEach(type => {
          const element = this.swatchControlsElements[type];
          if (!element) return;
          const components = type === 'rgb' ? ['r', 'g', 'b'] : ['h', 's', 'l'];
          const scales = type === 'rgb' ? [255, 255, 255] : [359, 100, 100];
          components.forEach((comp, index) => {
            const swatchLine = element.querySelector(`.swatch-${comp}`);
            if (!swatchLine) return;
            swatchLine.innerHTML = '';
            for (let i = 0; i < numSwatches; i++) {
              const normalizedVal = i * config.swatchCtrlStep;
              const val = (scales[index] * normalizedVal) / 100;
              const colorValues = { ...values };
              colorValues[comp] = Math.round(val);
              const rgb = type === 'rgb'
                ? colorValues
                : ColorModel.hslToRGB(colorValues.h, colorValues.s, colorValues.l);
              const hex = ColorModel.rgbToHex(Math.round(rgb.r), Math.round(rgb.g), Math.round(rgb.b));
              const swatch = document.createElement('div');
              swatch.className = 'swatch';
              swatch.style.backgroundColor = hex;
              swatch.style.width = `${swatchWidth}px`;
              swatch.title = Math.round(val);
              swatch.dataset[comp] = Math.round(val);
              const caret = document.createElement('div');
              caret.className = 'caret';
              swatch.appendChild(caret);
              swatchLine.appendChild(swatch);
            }

            const swatches = swatchLine.querySelectorAll('.swatch');
            const step = scales[index] / (swatches.length - 1);
            swatches.forEach((swatchEl, i) => {
              const swatchValue = i * step;
              const caret = swatchEl.querySelector('.caret');
              const isActive = values[comp] >= swatchValue && values[comp] < (swatchValue + step) ||
                (i === swatches.length - 1 && values[comp] >= swatchValue);
              caret.style.display = isActive ? 'block' : 'none';
            });
          });
        });
      }

    }

    // DOMContentLoaded to ensure DOM is ready
    document.addEventListener('DOMContentLoaded', () => {
      const dom = {
        rgbCanvas: document.getElementById('rgbCanvas'),
        hslCubeCanvas: document.getElementById('hslCubeCanvas'),
        hslCylinderCanvas: document.getElementById('hslCylinderCanvas'),
        colorSwatch: document.getElementById('colorSwatch'),
        hPlotToggle: document.getElementById('hPlotToggle'),
        sPlotToggle: document.getElementById('sPlotToggle'),
        lPlotToggle: document.getElementById('lPlotToggle'),
        rPlotToggle: document.getElementById('rPlotToggle'),
        gPlotToggle: document.getElementById('gPlotToggle'),
        bPlotToggle: document.getElementById('bPlotToggle'),
        tabCube: document.getElementById('tab-cube'),
        tabCylinder: document.getElementById('tab-cylinder'),
        hslCubeDiv: document.getElementById('hsl-cube-div'),
        hslCylinderDiv: document.getElementById('hsl-cylinder-div'),
        rgbSwatches: document.getElementById('rgb-swatches'),
        hslSwatches: document.getElementById('hsl-swatches'),
        rgbInputs: document.getElementById('rgb-inputs'),
        hslInputs: document.getElementById('hsl-inputs')
      };

      // Initialize models
      const rgbCube = new RGBCube(dom.rgbCanvas, dom.rgbCanvas.clientWidth || 500, dom.rgbCanvas.clientHeight || 400);
      const hslCube = new HSLCube(dom.hslCubeCanvas, dom.hslCubeCanvas.clientWidth || 500, dom.hslCubeCanvas.clientHeight || 400);
      const hslCylinder = new Cylinder(dom.hslCylinderCanvas, dom.hslCylinderCanvas.clientWidth || 500, dom.hslCylinderCanvas.clientHeight || 400);

      // Initialize ModelManager
      const modelManager = new ModelManager();

      // Register models
      modelManager.registerModel('rgb', rgbCube, dom.rgbCanvas.clientWidth || 500, dom.rgbCanvas.clientHeight || 400);
      modelManager.registerModel('hslCube', hslCube, dom.hslCubeCanvas.clientWidth || 500, dom.hslCubeCanvas.clientHeight || 400);
      modelManager.registerModel('hslCylinder', hslCylinder, dom.hslCylinderCanvas.clientWidth || 500, dom.hslCylinderCanvas.clientHeight || 400);

      // Initialize controls
      modelManager.swatchControls('rgb', dom.rgbSwatches);
      modelManager.swatchControls('hsl', dom.hslSwatches);
      modelManager.inputControls('rgb', dom.rgbInputs);
      modelManager.inputControls('hsl', dom.hslInputs);
      modelManager.currentSwatch(dom.colorSwatch);

      // Event listeners
      dom.tabCube.addEventListener('click', () => {
        dom.hslCubeDiv.classList.add('active');
        dom.hslCylinderDiv.classList.remove('active');
        dom.tabCube.classList.add('active');
        dom.tabCylinder.classList.remove('active');
        modelManager.dom.tooltip.style.display = 'none';
      });

      dom.tabCylinder.addEventListener('click', () => {
        dom.hslCubeDiv.classList.remove('active');
        dom.hslCylinderDiv.classList.add('active');
        dom.tabCube.classList.remove('active');
        dom.tabCylinder.classList.add('active');
      });

     // Toggle plot event listeners
    dom.hPlotToggle.addEventListener('change', () => rgbCube.setPlotSetting('h', dom.hPlotToggle.checked));
    dom.sPlotToggle.addEventListener('change', () => rgbCube.setPlotSetting('s', dom.sPlotToggle.checked));
    dom.lPlotToggle.addEventListener('change', () => rgbCube.setPlotSetting('l', dom.lPlotToggle.checked));
    dom.rPlotToggle.addEventListener('change', () => {
      hslCube.setPlotSetting('r', dom.rPlotToggle.checked);
      hslCylinder.setPlotSetting('r', dom.rPlotToggle.checked);
    });
    dom.gPlotToggle.addEventListener('change', () => {
      hslCube.setPlotSetting('g', dom.gPlotToggle.checked);
      hslCylinder.setPlotSetting('g', dom.gPlotToggle.checked);
    });
    dom.bPlotToggle.addEventListener('change', () => {
      hslCube.setPlotSetting('b', dom.bPlotToggle.checked);
      hslCylinder.setPlotSetting('b', dom.bPlotToggle.checked);
    });

      // Start animation
      modelManager.animate();
    });
  </script>
</body>
</html>